{"code": "public static String unEscapeString(String str,char escapeChar,char charToEscape){\n  return unEscapeString(str,escapeChar,new char[]{charToEscape});\n}\n", "nl": "Unescape <code>charToEscape</code> in the string with the escape char <code>escapeChar</code>"}
{"code": "public void checkNextPoissonConsistency(double mean){\n  final int sampleSize=1000;\n  final int minExpectedCount=7;\n  long maxObservedValue=0;\n  final double alpha=0.001;\n  UnitTestUtils.Frequency<Long> frequency=new UnitTestUtils.Frequency<Long>();\n  for (int i=0; i < sampleSize; i++) {\n    long value=randomData.nextPoisson(mean);\n    if (value > maxObservedValue) {\n      maxObservedValue=value;\n    }\n    frequency.addValue(value);\n  }\n  PoissonDistribution poissonDistribution=new PoissonDistribution(mean);\n  int lower=1;\n  while (poissonDistribution.cumulativeProbability(lower - 1) * sampleSize < minExpectedCount) {\n    lower++;\n  }\n  int upper=(int)(5 * mean);\n  while ((1 - poissonDistribution.cumulativeProbability(upper - 1)) * sampleSize < minExpectedCount) {\n    upper--;\n  }\n  int binWidth=0;\n  boolean widthSufficient=false;\n  double lowerBinMass=0;\n  double upperBinMass=0;\n  while (!widthSufficient) {\n    binWidth++;\n    lowerBinMass=poissonDistribution.probability(lower - 1,lower + binWidth - 1);\n    upperBinMass=poissonDistribution.probability(upper - binWidth - 1,upper - 1);\n    widthSufficient=FastMath.min(lowerBinMass,upperBinMass) * sampleSize >= minExpectedCount;\n  }\n  List<Integer> binBounds=new ArrayList<Integer>();\n  binBounds.add(lower);\n  int bound=lower + binWidth;\n  while (bound < upper - binWidth) {\n    binBounds.add(bound);\n    bound+=binWidth;\n  }\n  binBounds.add(upper);\n  final int binCount=binBounds.size() + 1;\n  long[] observed=new long[binCount];\n  double[] expected=new double[binCount];\n  observed[0]=0;\n  for (int i=0; i < lower; i++) {\n    observed[0]+=frequency.getCount((long)i);\n  }\n  expected[0]=poissonDistribution.cumulativeProbability(lower - 1) * sampleSize;\n  observed[binCount - 1]=0;\n  for (int i=upper; i <= maxObservedValue; i++) {\n    observed[binCount - 1]+=frequency.getCount((long)i);\n  }\n  expected[binCount - 1]=(1 - poissonDistribution.cumulativeProbability(upper - 1)) * sampleSize;\n  for (int i=1; i < binCount - 1; i++) {\n    observed[i]=0;\n    for (int j=binBounds.get(i - 1); j < binBounds.get(i); j++) {\n      observed[i]+=frequency.getCount((long)j);\n    }\n    expected[i]=(poissonDistribution.cumulativeProbability(binBounds.get(i) - 1) - poissonDistribution.cumulativeProbability(binBounds.get(i - 1) - 1)) * sampleSize;\n  }\n  if (UnitTestUtils.chiSquareTest(expected,observed) < alpha) {\n    StringBuilder msgBuffer=new StringBuilder();\n    DecimalFormat df=new DecimalFormat(\"#.##\");\n    msgBuffer.append(\"Chisquare test failed for mean = \");\n    msgBuffer.append(mean);\n    msgBuffer.append(\" p-value = \");\n    msgBuffer.append(UnitTestUtils.chiSquareTest(expected,observed));\n    msgBuffer.append(\" chisquare statistic = \");\n    msgBuffer.append(UnitTestUtils.chiSquare(expected,observed));\n    msgBuffer.append(\". \\n\");\n    msgBuffer.append(\"bin\\t\\texpected\\tobserved\\n\");\n    for (int i=0; i < expected.length; i++) {\n      msgBuffer.append(\"[\");\n      msgBuffer.append(i == 0 ? 1 : binBounds.get(i - 1));\n      msgBuffer.append(\",\");\n      msgBuffer.append(i == binBounds.size() ? \"inf\" : binBounds.get(i));\n      msgBuffer.append(\")\");\n      msgBuffer.append(\"\\t\\t\");\n      msgBuffer.append(df.format(expected[i]));\n      msgBuffer.append(\"\\t\\t\");\n      msgBuffer.append(observed[i]);\n      msgBuffer.append(\"\\n\");\n    }\n    msgBuffer.append(\"This test can fail randomly due to sampling error with probability \");\n    msgBuffer.append(alpha);\n    msgBuffer.append(\".\");\n    Assert.fail(msgBuffer.toString());\n  }\n}\n", "nl": "Verifies that nextPoisson(mean) generates an empirical distribution of values consistent with PoissonDistributionImpl by generating 1000 values, computing a grouped frequency distribution of the observed values and comparing this distribution to the corresponding expected distribution computed using PoissonDistributionImpl. Uses ChiSquare test of goodness of fit to evaluate the null hypothesis that the distributions are the same. If the null hypothesis can be rejected with confidence 1 - alpha, the check fails."}
{"code": "public DefaultJobRowBuilder(Function<Map<JobField,String>,String> idGenerator,Function<SecurityContext,String> userIdExtractor,Clock timestampGenerator){\n  this.idGenerator=idGenerator;\n  this.userIdExtractor=userIdExtractor;\n  this.timestampGenerator=timestampGenerator;\n}\n", "nl": "Builds a factory for generating JobRows with a custom function for extracting a userid from a request's SecurityContext."}
{"code": "protected final boolean handleAllocNode(AllocNode src){\n  boolean ret=false;\n  Node[] targets=pag.allocLookup(src);\n  for (  Node element : targets) {\n    if (element.makeP2Set().add(src)) {\n      varNodeWorkList.add((VarNode)element);\n      ret=true;\n    }\n  }\n  return ret;\n}\n", "nl": "Propagates new points-to information of node src to all its successors."}
{"code": "@Override protected FieldConfigBase createCopy(FieldConfigBase fieldConfigBase){\n  FieldConfigWKT copy=null;\n  if (fieldConfigBase != null) {\n    copy=new FieldConfigWKT(fieldConfigBase.getCommonData());\n  }\n  return copy;\n}\n", "nl": "Creates a copy of the field."}
{"code": "public void handleEntryExpiredSA(EntryExpiredBusPacket packet) throws Exception {\n  handleEntryExpiredCoreSA(packet.getEntryHolder(),packet.getTransaction(),packet.isFromReplication());\n}\n", "nl": "Handles EntryExpired packets."}
{"code": "public static SM_SYSTEM_MESSAGE STR_EXTRACT_GATHER_SUCCESS_1_BASIC(DescriptionId descriptionId){\n  return new SM_SYSTEM_MESSAGE(1330078,descriptionId);\n}\n", "nl": "You have gathered %0."}
{"code": "public void toggle(Animation animIn,Animation animOut){\n  toggle(true,animIn,animOut);\n}\n", "nl": "Toggle the badge visibility in the UI."}
{"code": "private boolean isInSameEvolutionChain(Pokemon p1,Pokemon p2){\n  ArrayList<Pokemon> evolutionLine=getEvolutionLine(p1);\n  for (  Pokemon poke : evolutionLine) {\n    if (poke.number == p2.number) {\n      return true;\n    }\n  }\n  return false;\n}\n", "nl": "Check if two pokemon are in the same complete evolution chain. Jolteon and vaporeon would return true"}
{"code": "public static SM_SYSTEM_MESSAGE STR_SKILL_SUCC_Aura_END_ME_TO_B(String skillname){\n  return new SM_SYSTEM_MESSAGE(1200459,skillname);\n}\n", "nl": "You stop using [%SkillName]."}
{"code": "public PhotosGetUploadServerQuery(VkApiClient client,UserActor actor){\n  super(client,\"photos.getUploadServer\",PhotoUpload.class);\n  accessToken(actor.getAccessToken());\n}\n", "nl": "Creates a AbstractQueryBuilder instance that can be used to build api request with various parameters"}
{"code": "public ChangeReport onEquipmentUnitAdd(final EquipmentUnitAdd equipmentUnitAdd){\n  log.debug(\"onEquipmentUnitAdd - entering onEquipmentUnitAdd()..\");\n  ChangeReport changeReport=new ChangeReport(equipmentUnitAdd);\n  changeReport.setState(CHANGE_STATE.SUCCESS);\n  ProcessConfiguration processConfiguration=configurationController.getProcessConfiguration();\n  if (processConfiguration.getEquipmentConfiguration(equipmentUnitAdd.getEquipmentId()) != null) {\n    changeReport.appendError(\"onEquipmentUnitAdd - Equipment unit id: \" + equipmentUnitAdd.getEquipmentId() + \" is already registered\");\n    changeReport.setState(CHANGE_STATE.FAIL);\n    return changeReport;\n  }\n  EquipmentConfiguration conf=null;\n  try {\n    conf=equipmentConfigurationFactory.createEquipmentConfiguration(equipmentUnitAdd.getEquipmentUnitXml());\n  }\n catch (  Exception ex) {\n    changeReport.setState(CHANGE_STATE.FAIL);\n    changeReport.appendError(StackTraceHelper.getStackTrace(ex));\n    return changeReport;\n  }\n  EquipmentMessageHandler equnit=null;\n  boolean dynamicTimeDeadbandEnabled=environment.getRequiredProperty(Options.DYNAMIC_TIME_DEADBAND_ENABLED,Boolean.class);\n  conf.setDynamicTimeDeadbandEnabled(dynamicTimeDeadbandEnabled);\n  log.info(\"onEquipmentUnitAdd - Dynamic timedeadband enabled for equipment id: \" + conf.getId() + \" enabled: \"+ dynamicTimeDeadbandEnabled);\n  EquipmentLoggerFactory equipmentLoggerFactory=EquipmentLoggerFactory.createFactory(conf,processConfiguration,environment.getProperty(\"c2mon.daq.logging.useEquipmentLoggers\",Boolean.class,false),environment.getProperty(\"c2mon.daq.logging.useEquipmentAppendersOnly\",Boolean.class,false));\n  EquipmentMessageSender equipmentMessageSender=(EquipmentMessageSender)applicationContext.getBean(EQUIPMENT_MESSAGE_SENDER);\n  equipmentMessageSender.init(conf,equipmentLoggerFactory);\n  configurationController.addCoreDataTagChanger(conf.getId(),equipmentMessageSender);\n  try {\n    validateDataTags(conf,equipmentMessageSender);\n    validateCommandTags(conf,equipmentMessageSender);\n    equnit=EquipmentMessageHandler.createEquipmentMessageHandler(conf.getHandlerClassName(),new EquipmentCommandHandler(conf.getId(),requestController),new EquipmentConfigurationHandler(conf.getId(),configurationController),equipmentMessageSender);\n    equnit.setEquipmentLoggerFactory(equipmentLoggerFactory);\n    processConfiguration.addEquipmentConfiguration(conf);\n  }\n catch (  InstantiationException e) {\n    String msg=\"Error while instantiating \" + conf.getHandlerClassName();\n    equipmentMessageSender.confirmEquipmentStateIncorrect(msg + \": \" + e.getMessage());\n    log.error(msg,e);\n  }\ncatch (  IllegalAccessException e) {\n    String msg=\"Access error while calling constructor of \" + conf.getHandlerClassName();\n    equipmentMessageSender.confirmEquipmentStateIncorrect(\"Error in code: \" + msg);\n    log.error(msg,e);\n  }\ncatch (  ClassNotFoundException e) {\n    String msg=\"Handler class not found: \" + conf.getHandlerClassName();\n    equipmentMessageSender.confirmEquipmentStateIncorrect(\"Error during configuration: \" + msg);\n    log.error(msg,e);\n  }\n  if (equnit != null) {\n    if (!registerNewEquipmentUnit(equnit)) {\n      changeReport.setState(CHANGE_STATE.REBOOT);\n      changeReport.appendWarn(\"problem detected while registering new equipment. You need to restart the DAQ\");\n    }\n  }\n  return changeReport;\n}\n", "nl": "Updates the DAQ by injecting new Equipment Unit"}
{"code": "private void requestNewPhotosOrders(Context c,int page,boolean refresh){\n  page=refresh ? 1 : page + 1;\n  listener=new OnRequestPhotosListener(c,page,Mysplash.CATEGORY_TOTAL_NEW,refresh,false);\n  model.getService().requestPhotos(page,Mysplash.DEFAULT_PER_PAGE,model.getPhotosOrder(),listener);\n}\n", "nl": "<br> utils."}
{"code": "public static void picture(double x,double y,String filename,double scaledWidth,double scaledHeight,double degrees){\n  if (scaledWidth < 0)   throw new IllegalArgumentException(\"width is negative: \" + scaledWidth);\n  if (scaledHeight < 0)   throw new IllegalArgumentException(\"height is negative: \" + scaledHeight);\n  Image image=getImage(filename);\n  double xs=scaleX(x);\n  double ys=scaleY(y);\n  double ws=factorX(scaledWidth);\n  double hs=factorY(scaledHeight);\n  if (ws < 0 || hs < 0)   throw new IllegalArgumentException(\"image \" + filename + \" is corrupt\");\n  if (ws <= 1 && hs <= 1)   pixel(x,y);\n  offscreen.rotate(Math.toRadians(-degrees),xs,ys);\n  offscreen.drawImage(image,(int)Math.round(xs - ws / 2.0),(int)Math.round(ys - hs / 2.0),(int)Math.round(ws),(int)Math.round(hs),null);\n  offscreen.rotate(Math.toRadians(+degrees),xs,ys);\n  draw();\n}\n", "nl": "Draws the specified image centered at (<em>x</em>, <em>y</em>), rotated given number of degrees, and rescaled to the specified bounding box. The supported image formats are JPEG, PNG, and GIF."}
{"code": "public VisualTable(Visualization vis,String group,Schema schema){\n  super(TableVisualItem.class);\n  init(vis,group,schema);\n}\n", "nl": "Create a new VisualTable without a parent table."}
{"code": "public boolean isCritical(){\n  return false;\n}\n", "nl": "is this a critical command that can only be executed when no other command is running?"}
{"code": "public static DataTag buildCreateBasicDataTag(Properties properties){\n  if (properties == null) {\n    properties=new Properties();\n  }\n  DataTag dataTag=DataTag.create(\"DataTag\",Integer.class,new DataTagAddress()).build();\n  dataTag.setEquipmentId(10L);\n  properties.setProperty(\"name\",\"DataTag\");\n  properties.setProperty(\"description\",\"<no description provided>\");\n  properties.setProperty(\"mode\",String.valueOf(TagMode.OPERATIONAL.ordinal()));\n  properties.setProperty(\"dataType\",Integer.class.getName());\n  properties.setProperty(\"isLogged\",String.valueOf(true));\n  properties.setProperty(\"equipmentId\",String.valueOf(10l));\n  properties.setProperty(\"address\",new DataTagAddress().toConfigXML());\n  return dataTag;\n}\n", "nl": "Expected generated id is 100. Expected parent id is 10."}
{"code": "protected void updateRowCount(){\n  int maxrow=m_rows.getMaximumRow() + 1;\n  Iterator cols=getColumns();\n  while (cols.hasNext()) {\n    Column c=(Column)cols.next();\n    c.setMaximumRow(maxrow);\n  }\n}\n", "nl": "Internal method that updates the row counts for local data columns."}
{"code": "public boolean isSelected(){\n  ClusterViewer viewer=getViewer();\n  return viewer.getPcoaTab() != null && viewer.getPcoaTab().isShowTriPlot();\n}\n", "nl": "this is currently selected?"}
{"code": "public int hashCode(){\n  return (int)(ConnectionRelativeTime.class.hashCode() + time);\n}\n", "nl": "Returns a hash code value for this object."}
{"code": "protected VideoRemoveTagQuery videoId(int value){\n  return unsafeParam(\"video_id\",value);\n}\n", "nl": "Video ID."}
{"code": "public static void cover(String dest,int w,int h,List<String> sources) throws Exception {\n  if (sources == null) {\n    throw new Exception(\"no source!\");\n  }\n  int len=sources.size();\n  if (len == 4 || len == 9) {\n    BufferedImage src[]=new BufferedImage[len];\n    for (int i=0; i < len; i++) {\n      src[i]=ImageIO.read(new File(sources.get(i)));\n    }\n    BufferedImage out=new BufferedImage(w,h,BufferedImage.TYPE_3BYTE_BGR);\n    Graphics g=out.getGraphics();\n    g.setColor(Color.WHITE);\n    g.fillRect(0,0,w,h);\n    g.setColor(new Color(0xCCD4D0));\n    int size=len == 4 ? 2 : 3;\n    int space=len == 4 ? 4 : 2;\n    int w1=(w - 1) / size;\n    int h1=(h - 1) / size;\n    float fd=((float)w1) / h1;\n    for (int i=0; i < len; i++) {\n      BufferedImage img=src[i];\n      int w2=img.getWidth();\n      int h2=img.getHeight();\n      float fs=((float)w2) / h2;\n      if (fs > fd) {\n        w2=w1;\n        h2=(int)(w2 / fs);\n      }\n else       if (fs < fd) {\n        h2=h1;\n        w2=(int)(h2 * fs);\n      }\n else {\n        w2=w1;\n        h2=h1;\n      }\n      Image tmp=img.getScaledInstance(w2,h2,Image.SCALE_SMOOTH);\n      int x=(i % size) * w1;\n      int y=(i / size) * h1;\n      g.drawImage(tmp,x + space + (w1 - w2) / 2,y + space + (h1 - h2) / 2,w2 - 2 * space,h2 - 2 * space,null);\n      g.drawRect(x,y,w1,h1);\n    }\n    ImageIO.write(out,\"jpg\",new File(dest));\n  }\n else {\n    throw new Exception(\"sources MUST is 4 or 9 picutures!\" + len);\n  }\n}\n", "nl": "make a Cover by source images."}
{"code": "public Bindings add(String property,JRadioButton[] cs,int defaultValue){\n  registerPropertyChangeListener(cs);\n  return add(new JRadioButtonBinding(property,cs,defaultValue));\n}\n", "nl": "Handles JRadioButton"}
{"code": "public void cancelAlarm(Context context){\n  if (alarmMgr != null) {\n    alarmMgr.cancel(alarmIntent);\n  }\n  ComponentName receiver=new ComponentName(context,BootReceiver.class);\n  PackageManager pm=context.getPackageManager();\n  pm.setComponentEnabledSetting(receiver,PackageManager.COMPONENT_ENABLED_STATE_DISABLED,PackageManager.DONT_KILL_APP);\n}\n", "nl": "Cancels the alarm."}
{"code": "public static SM_SYSTEM_MESSAGE STR_SKILL_SUCC_DispelNPCBuff_A_TO_SELF(String skillcaster,String skillname){\n  return new SM_SYSTEM_MESSAGE(1201257,skillcaster,skillname);\n}\n", "nl": "[%SkillCaster] dispelled its magical buffs by using [%SkillName]."}
{"code": "public static <T>T findValueOfType(Collection<T> collection,Class<? extends T>[] types){\n  if (isEmpty(collection) || ObjectUtils.isEmpty(types))   return null;\n  for (  Class<? extends T> type : types) {\n    T value=findValueOfType(collection,type);\n    if (value != null)     return value;\n  }\n  return null;\n}\n", "nl": "Find a value of one of the given types in the given collection: searching the collection for a value of the first type, then searching for a value of the second type, etc."}
{"code": "private static long writeLogSegment(DistributedLogManager dlm,int numRecords,long startTxId,int flushPerNumRecords,boolean emptyRecord) throws IOException {\n  long txid=startTxId;\n  LogWriter writer=dlm.startLogSegmentNonPartitioned();\n  for (long j=1; j <= numRecords; j++) {\n    if (emptyRecord) {\n      writer.write(DLMTestUtil.getEmptyLogRecordInstance(txid++));\n    }\n else {\n      writer.write(DLMTestUtil.getLargeLogRecordInstance(txid++));\n    }\n    if (j % flushPerNumRecords == 0) {\n      writer.setReadyToFlush();\n      writer.flushAndSync();\n    }\n  }\n  writer.setReadyToFlush();\n  writer.flushAndSync();\n  writer.close();\n  return txid;\n}\n", "nl": "Write <code>numRecords</code> records to the log, starting with <code>startTxId</code>. It flushes every <code>flushPerNumRecords</code> records."}
{"code": "@Override public void characters(char[] ch,int start,int length) throws SAXException {\n}\n", "nl": "PathElement is the only element having values inside -> nothing to do here. Doesn't care at the current state of parsing."}
{"code": "protected boolean runTestsOnEdt(){\n  return true;\n}\n", "nl": "Override to run tests off the EDT."}
{"code": "@Override public Histogram histogram(){\n  return hist;\n}\n", "nl": "Returns the histogram that approximates the join distribution of the field values of query results."}
{"code": "public CountriesExample(){\n  oredCriteria=new ArrayList<Criteria>();\n}\n", "nl": "This method was generated by MyBatis Generator. This method corresponds to the database table public.countries"}
{"code": "public Pair<Integer,Set<Long>> writeTable(long uuid){\n  preBufferAccess();\n  int offset=_buffer.position();\n  try {\n    if (_buffer.remaining() < 4) {\n      return Pair.<Integer,Set<Long>>create(-1,ImmutableSet.<Long>of());\n    }\n    _buffer.position(offset + 4);\n    Set<Long> uuids;\n    try {\n      ByteBuffer tableBuffer=_buffer.slice();\n      uuids=getTableSerializer().loadAndSerialize(uuid,new ByteBufferOutputStream(tableBuffer));\n      tableBuffer.flip();\n      int length=tableBuffer.limit();\n      _buffer.position(offset);\n      _buffer.putInt(length);\n      _buffer.position(offset + 4 + length);\n    }\n catch (    UnknownTableException|DroppedTableException e) {\n      uuids=ImmutableSet.of(uuid);\n      writeUnknownOrDroppedTable(offset,e);\n    }\n    _modified=true;\n    return Pair.create(offset,uuids);\n  }\n catch (  BufferOverflowException e) {\n    _buffer.position(offset);\n    if (offset == 0) {\n      _log.error(\"Table with UUID {} is too large to fit in a single block\",uuid);\n      throw new IllegalArgumentException(\"Table too large\");\n    }\n    return Pair.<Integer,Set<Long>>create(-1,ImmutableSet.<Long>of());\n  }\ncatch (  IOException e) {\n    throw Throwables.propagate(e);\n  }\n finally {\n    postBufferAccess();\n  }\n}\n", "nl": "Writes a table to the block.  Returns the offset in this block where the table was written, or -1 if there was insufficient room in the block to write the entire table."}
{"code": "public static boolean isBehind(VisibleObject object1,VisibleObject object2){\n  float angle=MathUtil.convertHeadingToDegree(object1.getHeading()) + 90;\n  if (angle >= 360) {\n    angle-=360;\n  }\n  double radian=Math.toRadians(angle);\n  float x0=object1.getX();\n  float y0=object1.getY();\n  float x1=(float)(Math.cos(radian) * 5) + x0;\n  float y1=(float)(Math.sin(radian) * 5) + y0;\n  float xA=object2.getX();\n  float yA=object2.getY();\n  float temp=(x1 - x0) * (yA - y0) - (y1 - y0) * (xA - x0);\n  return temp > 0;\n}\n", "nl": "Analyse two object position by coordinates"}
{"code": "void assignToBlock(BlockId blk){\n  internalLock.writeLock().lock();\n  try {\n    flush();\n    this.blk=blk;\n    contents.read(blk);\n    pins=0;\n    lastLsn=LogSeqNum.readFromPage(contents,LAST_LSN_OFFSET);\n  }\n  finally {\n    internalLock.writeLock().unlock();\n  }\n}\n", "nl": "Reads the contents of the specified block into the buffer's page. If the buffer was dirty, then the contents of the previous page are first written to disk."}
{"code": "public boolean contains(int index){\n  return index >= getFirst() && index <= getLast();\n}\n", "nl": "Tests whether item is contained by range"}
{"code": "@Override public boolean hasPassword(){\n  return propertyMap.containsKey(PASSWORD_KEY);\n}\n", "nl": "Checks for password."}
{"code": "public static SM_SYSTEM_MESSAGE STR_SKILL_SUCC_Protect_A_TO_ME(String skillcaster,String skillname){\n  return new SM_SYSTEM_MESSAGE(1200701,skillcaster,skillname);\n}\n", "nl": "[%SkillCaster] has protected you by using [%SkillName]."}
{"code": "protected Highlight buildHighlight(IDataSet set,int dataSetIndex,float xVal,DataSet.Rounding rounding){\n  final Entry e=set.getEntryForXPos(xVal,rounding);\n  if (e == null)   return null;\n  MPPointD pixels=mChart.getTransformer(set.getAxisDependency()).getPixelsForValues(e.getX(),e.getY());\n  return new Highlight(e.getX(),e.getY(),(float)pixels.x,(float)pixels.y,dataSetIndex,set.getAxisDependency());\n}\n", "nl": "Returns the Highlight object corresponding to the selected xValue and dataSetIndex."}
{"code": "public static SM_SYSTEM_MESSAGE STR_MSG_MY_PARTY_STATE(String value0){\n  return new SM_SYSTEM_MESSAGE(1390135,value0);\n}\n", "nl": "You changed the group to the %0 state."}
{"code": "private static void storeAsTypeWithSignaturesImport(String strTypeToImport,@Nullable Function objScope,PhpIndex objIndex,HashSet<String> objTypesSet){\n  if (strTypeToImport.contains(\"|\")) {\n    for (    String strOneType : strTypeToImport.split(\"\\\\|\")) {\n      storeAsTypeWithSignaturesImport(Types.getType(strOneType),objScope,objIndex,objTypesSet);\n    }\n    return;\n  }\n  if (StringUtil.isEmpty(strTypeToImport) || strTypeToImport.equals(\"?\")) {\n    return;\n  }\n  if (strTypeToImport.contains(\"#\")) {\n    TypeFromSignatureResolvingUtil.resolveSignature(strTypeToImport,objScope,objIndex,objTypesSet);\n    return;\n  }\n  objTypesSet.add(Types.getType(strTypeToImport));\n}\n", "nl": "adds type, handling | and #, invoking signatures resolving"}
{"code": "private V doGet(Object okey){\n  Comparable<? super K> key=comparable(okey);\n  for (; ; ) {\n    Node<K,V> n=findNode(key);\n    if (n == null)     return null;\n    Object v=n.value;\n    if (v != null)     return (V)v;\n  }\n}\n", "nl": "Gets value for key using findNode."}
{"code": "public JSONWriter key(String string) throws JSONException {\n  if (string == null) {\n    throw new JSONException(\"Null key.\");\n  }\n  if (this.mode == 'k') {\n    try {\n      this.stack[this.top - 1].putOnce(string,Boolean.TRUE);\n      if (this.comma) {\n        this.writer.write(',');\n      }\n      this.writer.write(JSONObject.quote(string));\n      this.writer.write(':');\n      this.comma=false;\n      this.mode='o';\n      return this;\n    }\n catch (    IOException e) {\n      throw new JSONException(e);\n    }\n  }\n  throw new JSONException(\"Misplaced key.\");\n}\n", "nl": "Append a key. The key will be associated with the next value. In an object, every value must be preceded by a key."}
{"code": "private boolean useIsSameNode(Node node){\n  if (node instanceof NodeImpl) {\n    return false;\n  }\n  Document doc=node.getNodeType() == Node.DOCUMENT_NODE ? (Document)node : node.getOwnerDocument();\n  return (doc != null && doc.getImplementation().hasFeature(\"Core\",\"3.0\"));\n}\n", "nl": "Use isSameNode() for testing node identity if the DOM implementation supports DOM Level 3 core and it isn't the Xerces implementation."}
{"code": "public boolean isExpired(Period period,Date now){\n  int expiryDays=getExpiryDays();\n  return expiryDays != DataSet.NO_EXPIRY && new DateTime(period.getEndDate()).plusDays(expiryDays).isBefore(new DateTime(now));\n}\n", "nl": "Indicates whether the given period is considered expired for the end date of the given date based on the expiry days of the data sets associated with this data element."}
{"code": "protected void at(String msg,boolean condition){\n  Assert.assertTrue(msg,condition);\n}\n", "nl": "Short for Assert.assertTrue"}
{"code": "@Deprecated public boolean isAssignableFrom(Type from){\n  if (from == null) {\n    return false;\n  }\n  if (type.equals(from)) {\n    return true;\n  }\n  if (type instanceof Class<?>) {\n    return rawType.isAssignableFrom($Gson$Types.getRawType(from));\n  }\n else   if (type instanceof ParameterizedType) {\n    return isAssignableFrom(from,(ParameterizedType)type,new HashMap<String,Type>());\n  }\n else   if (type instanceof GenericArrayType) {\n    return rawType.isAssignableFrom($Gson$Types.getRawType(from)) && isAssignableFrom(from,(GenericArrayType)type);\n  }\n else {\n    throw buildUnexpectedTypeError(type,Class.class,ParameterizedType.class,GenericArrayType.class);\n  }\n}\n", "nl": "Check if this type is assignable from the given Type."}
{"code": "private Collection<Var> migrateColumnValueAsRelation(Var parent,String fkName,String childType,Object childId){\n  if (childId == null) {\n    return Collections.emptyList();\n  }\n  String relationType=namer.relationName(fkName);\n  String childRole=namer.roleChildName(fkName);\n  String parentRole=namer.roleParentName(fkName);\n  String foreignPrimaryKey=namer.primaryKey(childType,Collections.singleton(childId.toString()));\n  Var child=var().isa(childType).id(foreignPrimaryKey);\n  Var relation=var().rel(childRole,var().id(id(child))).rel(parentRole,var().id(id(parent))).isa(relationType);\n  return Arrays.asList(child,relation);\n}\n", "nl": "Migrate a column value as a relation. This creates a target node with the ID of the foreign key and a relation from the given instance to this node."}
{"code": "protected void animateToState(boolean checked){\n  if (mProcessAnimator == null) {\n    return;\n  }\n  if (mProcessAnimator.isRunning()) {\n    mProcessAnimator.cancel();\n  }\n  mProcessAnimator.setDuration(mAnimationDuration);\n  if (checked) {\n    mProcessAnimator.setFloatValues(mProcess,1f);\n  }\n else {\n    mProcessAnimator.setFloatValues(mProcess,0);\n  }\n  mProcessAnimator.start();\n}\n", "nl": "processing animation"}
{"code": "@Override public Fraction reciprocal(){\n  return new Fraction(denominator,numerator);\n}\n", "nl": "Return the multiplicative inverse of this fraction."}
{"code": "public String listTargetFeatures(TargetFeatureComputer featureComputer,List<Element> segmentsAndBoundaries){\n  String pauseSymbol=featureComputer.getPauseSymbol();\n  List<Target> targets=overridableCreateTargetsWithPauses(segmentsAndBoundaries,pauseSymbol);\n  String header=featureComputer.getAllFeatureProcessorNamesAndValues();\n  StringBuilder text=new StringBuilder();\n  StringBuilder bin=new StringBuilder();\n  for (  Target target : targets) {\n    FeatureVector features=featureComputer.computeFeatureVector(target);\n    text.append(featureComputer.toStringValues(features)).append(\"\\n\");\n    bin.append(features.toString()).append(\"\\n\");\n  }\n  String out=header + \"\\n\" + text+ \"\\n\"+ bin;\n  return out;\n}\n", "nl": "For the given elements and using the given feature computer, create a string representation of the target features."}
{"code": "public void type(int... keys) throws InterruptedException {\n  for (  int key : keys) {\n    type(key);\n  }\n}\n", "nl": "Type a series of keys on the keyboard"}
{"code": "public FriendsAddQuery(VkApiClient client,UserActor actor,int userId){\n  super(client,\"friends.add\",AddResponse.class);\n  accessToken(actor.getAccessToken());\n  userId(userId);\n}\n", "nl": "Creates a AbstractQueryBuilder instance that can be used to build api request with various parameters"}
{"code": "public void clear(){\n  cache.invalidateAllData();\n}\n", "nl": "Only for UTs (for now), as this clears the whole ZK data cache."}
{"code": "@Override public void onConfigsUpdated(List<ConfigItem> configItems){\n  if (configItems != null && !configItems.isEmpty()) {\n    for (    ConfigItem configItem : configItems) {\n      configValues.put(configItem.getName(),configItem.getValue());\n    }\n  }\n}\n", "nl": "Refresh local configs"}
{"code": "@Override public boolean shouldSkipClass(Class<?> aClass){\n  return false;\n}\n", "nl": "Skips no classes."}
{"code": "private static Field[] fieldInfo(Entry entry){\n  Field[] fields=null;\nsynchronized (AbstractEntry.class) {\n    if (fieldArrays == null)     fieldArrays=new WeakHashMap();\n else {\n      fields=(Field[])fieldArrays.get(entry.getClass());\n      if (fields != null)       return fields;\n    }\n  }\n  final int SKIP_MODIFIERS=(Modifier.STATIC | Modifier.TRANSIENT | Modifier.FINAL);\n  fields=entry.getClass().getFields();\n  ArrayList usable=null;\n  for (int i=0; i < fields.length; i++) {\n    if ((fields[i].getModifiers() & SKIP_MODIFIERS) != 0 || (fields[i].getType().isPrimitive())) {\n      if (usable == null) {\n        usable=new ArrayList();\n        for (int j=0; j < i; j++)         usable.add(fields[j]);\n      }\n    }\n else {\n      if (usable != null)       usable.add(fields[i]);\n    }\n  }\n  if (usable != null)   fields=(Field[])usable.toArray(new Field[usable.size()]);\nsynchronized (AbstractEntry.class) {\n    fieldArrays.put(entry.getClass(),fields);\n  }\n  return fields;\n}\n", "nl": "Calculate the list of usable fields for this type"}
{"code": "public boolean equals(Object obj){\n  return obj == this || (obj != null && obj.getClass() == getClass() && instance.equals(((MarshalledWrapper)obj).instance));\n}\n", "nl": "Compares the specified object with this <code>MarshalledWrapper</code> for equality.  This method returns <code>true</code> if and only if the specified object is of the same class as this object and its wrapped <code>MarshalledInstance</code> is equal to the one in this object."}
{"code": "protected static Dfp atanInternal(final Dfp a){\n  Dfp y=new Dfp(a);\n  Dfp x=new Dfp(y);\n  Dfp py=new Dfp(y);\n  for (int i=3; i < 90; i+=2) {\n    x=x.multiply(a);\n    x=x.multiply(a);\n    x=x.negate();\n    y=y.add(x.divide(i));\n    if (y.equals(py)) {\n      break;\n    }\n    py=new Dfp(y);\n  }\n  return y;\n}\n", "nl": "computes the arc-tangent of the argument."}
{"code": "private void flush(){\n  myPage.write(currentBlk);\n  lastFlushedLsn=lastLsn;\n}\n", "nl": "Writes the current page to the log file."}
{"code": "private XtnConfilctCheckIndicators checkTransactionConflict(Context context,IEntryHolder entry,ITemplateHolder template,boolean isShadow){\n  XtnEntry xtnEntry;\n  if ((template.getTemplateOperation() == SpaceOperations.READ || template.getTemplateOperation() == SpaceOperations.READ_IE) && !template.isExclusiveReadLockOperation()) {\n    ITransactionalEntryData edata=context.isNonBlockingReadOp() ? context.getLastRawMatchSnapshot() : entry.getTxnEntryData();\n    xtnEntry=edata.getWriteLockOwner();\n    if (xtnEntry == null)     return XtnConfilctCheckIndicators.NO_CONFLICT;\n    final XtnStatus entryWriteLockStatus=xtnEntry.getStatus();\n    final int entryWriteLockOperation=edata.getWriteLockOperation();\n    final boolean isDirtyRead=indicateDirtyRead(template);\n    final boolean isReadCommitted=indicateReadCommitted(edata,template);\n    if (template.getXidOriginatedTransaction() == null || !edata.getWriteLockTransaction().equals(template.getXidOriginatedTransaction())) {\n      if (isDirtyRead)       return checkTransactionConflictDirtyRead(context,xtnEntry,entryWriteLockStatus,entryWriteLockOperation,entry,edata,isShadow);\n      if (isReadCommitted)       return checkTransactionConflictReadCommitted(context,xtnEntry,entryWriteLockStatus,entryWriteLockOperation,entry,edata,isShadow);\n      return checkTransactionConflict(xtnEntry,entryWriteLockStatus,entryWriteLockOperation);\n    }\n    if (entryWriteLockOperation == SpaceOperations.TAKE || entryWriteLockOperation == SpaceOperations.TAKE_IE)     return XtnConfilctCheckIndicators.DELETED_BY_OWN_XTN;\n    if (isReadCommitted && isShadow)     return XtnConfilctCheckIndicators.XTN_CONFLICT;\n    return XtnConfilctCheckIndicators.NO_CONFLICT;\n  }\n  if ((template.getTemplateOperation() == SpaceOperations.TAKE_IE || template.getTemplateOperation() == SpaceOperations.TAKE)) {\n    List<XtnEntry> readWriteLock=entry.getReadLockOwners();\n    if (entry.getWriteLockTransaction() == null && (readWriteLock == null || readWriteLock.isEmpty()))     return XtnConfilctCheckIndicators.NO_CONFLICT;\n    if (readWriteLock != null && !readWriteLock.isEmpty()) {\n      for (      XtnEntry readLockOwner : readWriteLock) {\n        xtnEntry=readLockOwner;\n        if (xtnEntry != null) {\n          XtnStatus entryReadLockStatus=xtnEntry.getStatus();\n          if (entryReadLockStatus == XtnStatus.COMMITED || entryReadLockStatus == XtnStatus.COMMITING || (entryReadLockStatus == XtnStatus.PREPARED && xtnEntry.m_SingleParticipant) || entryReadLockStatus == XtnStatus.ROLLED || (entryReadLockStatus == XtnStatus.ROLLING && !xtnEntry.m_AlreadyPrepared))           continue;\n          if (template.getXidOriginatedTransaction() == null || !readLockOwner.m_Transaction.equals(template.getXidOriginatedTransaction()))           return XtnConfilctCheckIndicators.XTN_CONFLICT;\n        }\n      }\n    }\n    xtnEntry=entry.getWriteLockOwner();\n    if (xtnEntry == null)     return XtnConfilctCheckIndicators.NO_CONFLICT;\n    XtnStatus entryWriteLockStatus=xtnEntry.getStatus();\n    int entryWriteLockOperation=entry.getWriteLockOperation();\n    if (template.getXidOriginatedTransaction() == null || !entry.getWriteLockTransaction().equals(template.getXidOriginatedTransaction())) {\n      return checkTransactionConflict(xtnEntry,entryWriteLockStatus,entryWriteLockOperation);\n    }\n    if (entryWriteLockOperation == SpaceOperations.TAKE || entryWriteLockOperation == SpaceOperations.TAKE_IE)     return XtnConfilctCheckIndicators.DELETED_BY_OWN_XTN;\n    return XtnConfilctCheckIndicators.NO_CONFLICT;\n  }\n  if (template.getTemplateOperation() == SpaceOperations.UPDATE || template.isExclusiveReadLockOperation()) {\n    List<XtnEntry> rwLock=entry.getReadLockOwners();\n    if (entry.getWriteLockTransaction() == null && (rwLock == null || rwLock.isEmpty()))     return XtnConfilctCheckIndicators.NO_CONFLICT;\n    if (rwLock != null && !rwLock.isEmpty()) {\n      for (      XtnEntry readLockOwner : rwLock) {\n        xtnEntry=readLockOwner;\n        if (xtnEntry != null) {\n          XtnStatus entryReadLockStatus=xtnEntry.getStatus();\n          if (entryReadLockStatus == XtnStatus.COMMITED || entryReadLockStatus == XtnStatus.COMMITING || (entryReadLockStatus == XtnStatus.PREPARED && xtnEntry.m_SingleParticipant) || entryReadLockStatus == XtnStatus.ROLLED || (entryReadLockStatus == XtnStatus.ROLLING && !xtnEntry.m_AlreadyPrepared))           continue;\n          if (template.getXidOriginatedTransaction() == null || !readLockOwner.m_Transaction.equals(template.getXidOriginatedTransaction()))           return XtnConfilctCheckIndicators.XTN_CONFLICT;\n        }\n      }\n    }\n    xtnEntry=entry.getWriteLockOwner();\n    if (xtnEntry == null)     return XtnConfilctCheckIndicators.NO_CONFLICT;\n    XtnStatus entryWriteLockStatus=xtnEntry.getStatus();\n    int entryWriteLockOperation=entry.getWriteLockOperation();\n    if (template.getXidOriginatedTransaction() == null || !entry.getWriteLockTransaction().equals(template.getXidOriginatedTransaction())) {\n      return checkTransactionConflict(xtnEntry,entryWriteLockStatus,entryWriteLockOperation);\n    }\n    if (entryWriteLockOperation == SpaceOperations.TAKE || entryWriteLockOperation == SpaceOperations.TAKE_IE)     return UpdateModifiers.isUpdateOrWrite(template.getOperationModifiers()) ? XtnConfilctCheckIndicators.NO_CONFLICT : XtnConfilctCheckIndicators.DELETED_BY_OWN_XTN;\n    if (template.isFifoGroupPoll() && xtnEntry == template.getXidOriginated() && template.isExclusiveReadLockOperation())     return XtnConfilctCheckIndicators.DELETED_BY_OWN_XTN;\n    return XtnConfilctCheckIndicators.NO_CONFLICT;\n  }\n  return XtnConfilctCheckIndicators.NO_CONFLICT;\n}\n", "nl": "Checks if there is a transaction conflict between the specified entry and the operation implied by the specified template. templateTransaction is not null if template is under xtn isShadow is true if the call is on behalf of a shadow entry"}
{"code": "public boolean freePage(int pageNum){\n  Page p;\n  try {\n    p=fetchPage(pageNum);\n  }\n catch (  PageException e) {\n    return false;\n  }\n  return freePage(p);\n}\n", "nl": "Frees the page to be returned back to the system. The page is no longer valid and can be re-used the next time the user called allocPage."}
{"code": "public synchronized void openDriver(SurfaceHolder holder) throws IOException {\n  Camera theCamera=camera;\n  if (theCamera == null) {\n    if (requestedCameraId >= 0) {\n      theCamera=OpenCameraInterface.open(requestedCameraId);\n    }\n else {\n      theCamera=OpenCameraInterface.open();\n    }\n    if (theCamera == null) {\n      throw new IOException();\n    }\n    camera=theCamera;\n  }\n  theCamera.setPreviewDisplay(holder);\n  if (!initialized) {\n    initialized=true;\n    configManager.initFromCameraParameters(theCamera);\n  }\n  Camera.Parameters parameters=theCamera.getParameters();\n  String parametersFlattened=parameters == null ? null : parameters.flatten();\n  try {\n    configManager.setDesiredCameraParameters(theCamera,false);\n  }\n catch (  RuntimeException re) {\n    Log.w(TAG,\"Camera rejected parameters. Setting only minimal safe-mode parameters\");\n    Log.i(TAG,\"Resetting to saved camera params: \" + parametersFlattened);\n    if (parametersFlattened != null) {\n      parameters=theCamera.getParameters();\n      parameters.unflatten(parametersFlattened);\n      try {\n        theCamera.setParameters(parameters);\n        configManager.setDesiredCameraParameters(theCamera,true);\n      }\n catch (      RuntimeException re2) {\n        Log.w(TAG,\"Camera rejected even safe-mode parameters! No configuration\");\n      }\n    }\n  }\n}\n", "nl": "Opens the camera driver and initializes the hardware parameters."}
{"code": "@Override public IntegerDistribution makeDistribution(){\n  return new GeometricDistribution(0.40);\n}\n", "nl": "Creates the default discrete distribution instance to use in tests."}
{"code": "public final boolean isOverridingLocale(){\n  return (myOverride & CFG_LOCALE) != 0;\n}\n", "nl": "Returns true if the locale is overridden"}
{"code": "public static ContourNextLinkMessage fromBytes(MedtronicCNLSession pumpSession,byte[] bytes) throws ChecksumException, EncryptionException {\n  ContourNextLinkMessage message=MedtronicMessage.fromBytes(bytes);\n  if (bytes.length >= 57) {\n    byte encryptedPayloadSize=bytes[56];\n    ByteBuffer encryptedPayload=ByteBuffer.allocate(encryptedPayloadSize);\n    encryptedPayload.put(bytes,57,encryptedPayloadSize);\n    byte[] decryptedPayload=decrypt(pumpSession.getKey(),pumpSession.getIV(),encryptedPayload.array());\n    message.mPayload.position(57);\n    message.mPayload.put(decryptedPayload);\n  }\n  return message;\n}\n", "nl": "MedtronicReceiveMessage: +------------------+-----------------+-----------------+---------------------------------+-------------------+--------------------------------+ | LE short unknown | LE long pumpMAC | LE long linkMAC | byte[3] responseSequenceNumber? | byte Payload size | byte[] Encrypted Payload bytes | +------------------+-----------------+-----------------+---------------------------------+-------------------+--------------------------------+ <p/> MedtronicReceiveMessage (decrypted payload): +----------------------------+-----------------------------+----------------------+--------------------+ | byte receiveSequenceNumber | BE short receiveMessageType | byte[] Payload bytes | BE short CCITT CRC | +----------------------------+-----------------------------+----------------------+--------------------+"}
{"code": "public Builder popupAnchor(Point popupAnchor){\n  this.popupAnchor=popupAnchor;\n  return this;\n}\n", "nl": "The coordinates of the point from which popups will \"open\", relative to the icon anchor."}
{"code": "@deprecated protected DictionaryBasedBreakIterator(InputStream compiledRules) throws IOException {\n  this.fRData=RBBIDataWrapper.get(compiledRules);\n  this.dictionary=null;\n  this.usingCTDictionary=true;\n}\n", "nl": "/*    "}
{"code": "public Builder boxZoom(Boolean boxZoom){\n  this.boxZoom=boxZoom;\n  return this;\n}\n", "nl": "Whether the map can be zoomed to a rectangular area specified by dragging the mouse while pressing shift. default true"}
{"code": "@Override public void undoAction(UndoInterface undoRedoObject){\n  if (comboBox != null) {\n    String oldValue=(String)undoRedoObject.getOldValue();\n    comboBox.setSelectValueKey(oldValue);\n  }\n}\n", "nl": "Undo action."}
{"code": "public void removeRule(Rule ruleToDelete){\n  List<Rule> ruleList=(List<Rule>)this.symbolData.getFeatureTypeStyle().rules();\n  int indexFound=-1;\n  int index=0;\n  for (  Rule rule : ruleList) {\n    if (rule == ruleToDelete) {\n      indexFound=index;\n      break;\n    }\n else {\n      index++;\n    }\n  }\n  if (indexFound > -1) {\n    ruleList.remove(indexFound);\n  }\n}\n", "nl": "Removes the rule."}