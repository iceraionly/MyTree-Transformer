{"code": "protected void tearDown(){\n}\n", "nl": "Tears down the fixture, for example, close a network connection. This method is called after a test is executed."}
{"code": "@KnownFailure(\"Fixed on DonutBurger, Wrong Exception thrown\") public void test_unwrap_ByteBuffer$ByteBuffer_02(){\n  String host=\"new host\";\n  int port=8080;\n  ByteBuffer bbs=ByteBuffer.allocate(10);\n  ByteBuffer bbR=ByteBuffer.allocate(100).asReadOnlyBuffer();\n  ByteBuffer[] bbA={bbR,ByteBuffer.allocate(10),ByteBuffer.allocate(100)};\n  SSLEngine sse=getEngine(host,port);\n  sse.setUseClientMode(true);\n  try {\n    sse.unwrap(bbs,bbA);\n    fail(\"ReadOnlyBufferException wasn't thrown\");\n  }\n catch (  ReadOnlyBufferException iobe) {\n  }\ncatch (  Exception e) {\n    fail(e + \" was thrown instead of ReadOnlyBufferException\");\n  }\n}\n", "nl": "javax.net.ssl.SSLEngine#unwrap(ByteBuffer src, ByteBuffer[] dsts) ReadOnlyBufferException should be thrown."}
{"code": "public static CstFloat make(int bits){\n  return new CstFloat(bits);\n}\n", "nl": "Makes an instance for the given value. This may (but does not necessarily) return an already-allocated instance."}
{"code": "public long size(){\n  long size=0;\n  if (parsedGeneExpressions == null)   parseGenes();\n  for (int i=0; i < parsedGeneExpressions.length; i++)   size+=parsedGeneExpressions[i].numberOfNodes();\n  return size;\n}\n", "nl": "Returns the \"size\" of the chromosome, namely, the number of nodes in all of its parsed genes -- does not include the linking functions. "}
{"code": "public void increment(View view){\n  if (quantity == 100) {\n    return;\n  }\n  quantity=quantity + 1;\n  displayQuantity(quantity);\n}\n", "nl": "This method is called when the plus button is clicked."}
{"code": "public void trimToSize(){\n  ++modCount;\n  if (size < elementData.length) {\n    elementData=Arrays.copyOf(elementData,size);\n  }\n}\n", "nl": "Trims the capacity of this <tt>ArrayHashList</tt> instance to be the list's current size. An application can use this operation to minimize the storage of an <tt>ArrayHashList</tt> instance."}
{"code": "public SyncValueResponseMessage(SyncValueResponseMessage other){\n  __isset_bitfield=other.__isset_bitfield;\n  if (other.isSetHeader()) {\n    this.header=new AsyncMessageHeader(other.header);\n  }\n  this.count=other.count;\n}\n", "nl": "Performs a deep copy on <i>other</i>."}
{"code": "public void clearParsers(){\n  if (parserManager != null) {\n    parserManager.clearParsers();\n  }\n}\n", "nl": "Removes all parsers from this text area."}
{"code": "@Override public void run(){\n  while (doWork) {\n    deliverLock();\n    while (tomLayer.isRetrievingState()) {\n      System.out.println(\"-- Retrieving State\");\n      canDeliver.awaitUninterruptibly();\n      if (tomLayer.getLastExec() == -1)       System.out.println(\"-- Ready to process operations\");\n    }\n    try {\n      ArrayList<Decision> decisions=new ArrayList<Decision>();\n      decidedLock.lock();\n      if (decided.isEmpty()) {\n        notEmptyQueue.await();\n      }\n      decided.drainTo(decisions);\n      decidedLock.unlock();\n      if (!doWork)       break;\n      if (decisions.size() > 0) {\n        TOMMessage[][] requests=new TOMMessage[decisions.size()][];\n        int[] consensusIds=new int[requests.length];\n        int[] leadersIds=new int[requests.length];\n        int[] regenciesIds=new int[requests.length];\n        CertifiedDecision[] cDecs;\n        cDecs=new CertifiedDecision[requests.length];\n        int count=0;\n        for (        Decision d : decisions) {\n          requests[count]=extractMessagesFromDecision(d);\n          consensusIds[count]=d.getConsensusId();\n          leadersIds[count]=d.getLeader();\n          regenciesIds[count]=d.getRegency();\n          CertifiedDecision cDec=new CertifiedDecision(this.controller.getStaticConf().getProcessId(),d.getConsensusId(),d.getValue(),d.getDecisionEpoch().proof);\n          cDecs[count]=cDec;\n          if (requests[count][0].equals(d.firstMessageProposed)) {\n            long time=requests[count][0].timestamp;\n            long seed=requests[count][0].seed;\n            int numOfNonces=requests[count][0].numOfNonces;\n            requests[count][0]=d.firstMessageProposed;\n            requests[count][0].timestamp=time;\n            requests[count][0].seed=seed;\n            requests[count][0].numOfNonces=numOfNonces;\n          }\n          count++;\n        }\n        Decision lastDecision=decisions.get(decisions.size() - 1);\n        if (requests != null && requests.length > 0) {\n          deliverMessages(consensusIds,regenciesIds,leadersIds,cDecs,requests);\n          if (controller.hasUpdates()) {\n            processReconfigMessages(lastDecision.getConsensusId());\n            tomLayer.setLastExec(lastDecision.getConsensusId());\n            tomLayer.setInExec(-1);\n          }\n        }\n        int cid=lastDecision.getConsensusId();\n        if (cid > 2) {\n          int stableConsensus=cid - 3;\n          tomLayer.execManager.removeConsensus(stableConsensus);\n        }\n      }\n    }\n catch (    Exception e) {\n      e.printStackTrace(System.err);\n    }\n    deliverUnlock();\n  }\n  java.util.logging.Logger.getLogger(DeliveryThread.class.getName()).log(Level.INFO,\"DeliveryThread stopped.\");\n}\n", "nl": "This is the code for the thread. It delivers decisions to the TOM request receiver object (which is the application)"}
{"code": "private byte[] calculateUValue(byte[] generalKey,byte[] firstDocIdValue,int revision) throws GeneralSecurityException, EncryptionUnsupportedByProductException {\n  if (revision == 2) {\n    Cipher rc4=createRC4Cipher();\n    SecretKey key=createRC4Key(generalKey);\n    initEncryption(rc4,key);\n    return crypt(rc4,PW_PADDING);\n  }\n else   if (revision >= 3) {\n    MessageDigest md5=createMD5Digest();\n    md5.update(PW_PADDING);\n    if (firstDocIdValue != null) {\n      md5.update(firstDocIdValue);\n    }\n    final byte[] hash=md5.digest();\n    Cipher rc4=createRC4Cipher();\n    SecretKey key=createRC4Key(generalKey);\n    initEncryption(rc4,key);\n    final byte[] v=crypt(rc4,hash);\n    rc4shuffle(v,generalKey,rc4);\n    assert v.length == 16;\n    final byte[] entryValue=new byte[32];\n    System.arraycopy(v,0,entryValue,0,v.length);\n    System.arraycopy(v,0,entryValue,16,v.length);\n    return entryValue;\n  }\n else {\n    throw new EncryptionUnsupportedByProductException(\"Unsupported standard security handler revision \" + revision);\n  }\n}\n", "nl": "Calculate what the U value should consist of given a particular key and document configuration. Correponds to Algorithms 3.4 and 3.5 of the PDF Reference version 1.7"}
{"code": "private void assign(HashMap<String,DBIDs> labelMap,String label,DBIDRef id){\n  if (labelMap.containsKey(label)) {\n    DBIDs exist=labelMap.get(label);\n    if (exist instanceof DBID) {\n      ModifiableDBIDs n=DBIDUtil.newHashSet();\n      n.add((DBID)exist);\n      n.add(id);\n      labelMap.put(label,n);\n    }\n else {\n      assert (exist instanceof HashSetModifiableDBIDs);\n      assert (exist.size() > 1);\n      ((ModifiableDBIDs)exist).add(id);\n    }\n  }\n else {\n    labelMap.put(label,DBIDUtil.deref(id));\n  }\n}\n", "nl": "Assigns the specified id to the labelMap according to its label"}
{"code": "private void showFeedback(String message){\n  if (myHost != null) {\n    myHost.showFeedback(message);\n  }\n else {\n    System.out.println(message);\n  }\n}\n", "nl": "Used to communicate feedback pop-up messages between a plugin tool and the main Whitebox user-interface."}
{"code": "public CDeleteAction(final BackEndDebuggerProvider debuggerProvider,final int[] rows){\n  super(rows.length == 1 ? \"Remove Breakpoint\" : \"Remove Breakpoints\");\n  m_debuggerProvider=Preconditions.checkNotNull(debuggerProvider,\"IE01344: Debugger provider argument can not be null\");\n  m_rows=rows.clone();\n}\n", "nl": "Creates a new action object."}
{"code": "public Yaml(BaseConstructor constructor,Representer representer,DumperOptions dumperOptions,Resolver resolver){\n  if (!constructor.isExplicitPropertyUtils()) {\n    constructor.setPropertyUtils(representer.getPropertyUtils());\n  }\n else   if (!representer.isExplicitPropertyUtils()) {\n    representer.setPropertyUtils(constructor.getPropertyUtils());\n  }\n  this.constructor=constructor;\n  representer.setDefaultFlowStyle(dumperOptions.getDefaultFlowStyle());\n  representer.setDefaultScalarStyle(dumperOptions.getDefaultScalarStyle());\n  representer.getPropertyUtils().setAllowReadOnlyProperties(dumperOptions.isAllowReadOnlyProperties());\n  representer.setTimeZone(dumperOptions.getTimeZone());\n  this.representer=representer;\n  this.dumperOptions=dumperOptions;\n  this.resolver=resolver;\n  this.name=\"Yaml:\" + System.identityHashCode(this);\n}\n", "nl": "Create Yaml instance. It is safe to create a few instances and use them in different Threads."}
{"code": "public void testHitEndAfterFind(){\n  hitEndTest(true,\"#01.0\",\"r((ege)|(geg))x\",\"regexx\",false);\n  hitEndTest(true,\"#01.1\",\"r((ege)|(geg))x\",\"regex\",false);\n  hitEndTest(true,\"#01.2\",\"r((ege)|(geg))x\",\"rege\",true);\n  hitEndTest(true,\"#01.2\",\"r((ege)|(geg))x\",\"xregexx\",false);\n  hitEndTest(true,\"#02.0\",\"regex\",\"rexreger\",true);\n  hitEndTest(true,\"#02.1\",\"regex\",\"raxregexr\",false);\n  String floatRegex=getHexFloatRegex();\n  hitEndTest(true,\"#03.0\",floatRegex,Double.toHexString(-1.234d),true);\n  hitEndTest(true,\"#03.1\",floatRegex,\"1 ABC\" + Double.toHexString(Double.NaN) + \"buhuhu\",false);\n  hitEndTest(true,\"#03.2\",floatRegex,Double.toHexString(-0.0) + \"--\",false);\n  hitEndTest(true,\"#03.3\",floatRegex,\"--\" + Double.toHexString(Double.MIN_VALUE) + \"--\",false);\n  hitEndTest(true,\"#04.0\",\"(\\\\d+) fish (\\\\d+) fish (\\\\w+) fish (\\\\d+)\",\"1 fish 2 fish red fish 5\",true);\n  hitEndTest(true,\"#04.1\",\"(\\\\d+) fish (\\\\d+) fish (\\\\w+) fish (\\\\d+)\",\"----1 fish 2 fish red fish 5----\",false);\n}\n", "nl": "Regression test for HARMONY-4396"}
{"code": "public void add(Individual individual){\n  individuals.add(individual);\n}\n", "nl": "Adds a single individual."}
{"code": "public boolean removeSession(IgniteUuid sesId){\n  GridTaskSessionImpl ses=sesMap.get(sesId);\n  assert ses == null || ses.isFullSupport();\n  if (ses != null && ses.release()) {\n    sesMap.remove(sesId,ses);\n    return true;\n  }\n  return false;\n}\n", "nl": "Removes session for a given session ID."}
{"code": "public static Bitmap loadBitmapOptimized(Uri uri,Context context,int limit) throws ImageLoadException {\n  return loadBitmapOptimized(new UriSource(uri,context){\n  }\n,limit);\n}\n", "nl": "Loading bitmap with optimized loaded size less than specific pixels count"}
{"code": "protected BasePeriod(long duration){\n  super();\n  iType=PeriodType.standard();\n  int[] values=ISOChronology.getInstanceUTC().get(DUMMY_PERIOD,duration);\n  iValues=new int[8];\n  System.arraycopy(values,0,iValues,4,4);\n}\n", "nl": "Creates a period from the given millisecond duration with the standard period type and ISO rules, ensuring that the calculation is performed with the time-only period type. <p> The calculation uses the hour, minute, second and millisecond fields."}
{"code": "public FlatBufferBuilder(){\n  this(1024);\n}\n", "nl": "Start with a buffer of 1KiB, then grow as required."}
{"code": "public PbrpcConnectionException(String arg0,Throwable arg1){\n  super(arg0,arg1);\n}\n", "nl": "Creates a new instance of PbrpcConnectionException."}
{"code": "public void uninstallUI(JComponent a){\n  for (int i=0; i < uis.size(); i++) {\n    ((ComponentUI)(uis.elementAt(i))).uninstallUI(a);\n  }\n}\n", "nl": "Invokes the <code>uninstallUI</code> method on each UI handled by this object."}
{"code": "public static void shutdown(){\n  if (instance != null) {\n    instance.save();\n  }\n}\n", "nl": "Saves the configuration file."}
{"code": "public boolean GE(Word w2){\n  return value.GE(w2.value);\n}\n", "nl": "Greater-than or equal comparison"}
{"code": "public static UnionCoder of(List<Coder<?>> elementCoders){\n  return new UnionCoder(elementCoders);\n}\n", "nl": "Builds a union coder with the given list of element coders.  This list corresponds to a mapping of union tag to Coder.  Union tags start at 0."}
{"code": "public void testFileDeletion() throws Exception {\n  File testDir=createTestDir(\"testFileDeletion\");\n  String prefix1=\"testFileDeletion1\";\n  File[] files1=createFiles(testDir,prefix1,5);\n  String prefix2=\"testFileDeletion2\";\n  File[] files2=createFiles(testDir,prefix2,5);\n  FileCommands.deleteFiles(files1,true);\n  assertNotExists(files1);\n  FileCommands.deleteFiles(files2,false);\n  Thread.sleep(1000);\n  assertNotExists(files2);\n}\n", "nl": "Verify ability to delete a list of files."}
{"code": "public boolean isOnClasspath(String classpath){\n  return this.classpath.equals(classpath);\n}\n", "nl": "Evaluates if the Dependency is targeted for a classpath type."}
{"code": "protected void source(String ceylon){\n  String providerPreSrc=\"provider/\" + ceylon + \"_pre.ceylon\";\n  String providerPostSrc=\"provider/\" + ceylon + \"_post.ceylon\";\n  String clientSrc=\"client/\" + ceylon + \"_client.ceylon\";\n  compile(providerPreSrc,providerModuleSrc,providerPackageSrc);\n  compile(clientSrc,clientModuleSrc);\n  compile(providerPostSrc,providerModuleSrc,providerPackageSrc);\n  compile(clientSrc,clientModuleSrc);\n}\n", "nl": "Checks that we can still compile a client after a change"}
{"code": "public PerformanceMonitor(){\n  initComponents();\n  if (Display.getInstance().getCurrent() != null) {\n    refreshFrameActionPerformed(null);\n  }\n  resultData.setModel(new Model());\n  performanceLog.setLineWrap(true);\n  resultData.setRowSorter(new TableRowSorter<Model>((Model)resultData.getModel()));\n}\n", "nl": "Creates new form PerformanceMonitor"}
{"code": "@DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2014-09-03 15:01:15.190 -0400\",hash_original_method=\"F262A3A18BABECF7EC492736953EAF6E\",hash_generated_method=\"94A4545C167C029CC38AACEACF2087E9\") private void unparkSuccessor(Node node){\n  int ws=node.waitStatus;\n  if (ws < 0)   compareAndSetWaitStatus(node,ws,0);\n  Node s=node.next;\n  if (s == null || s.waitStatus > 0) {\n    s=null;\n    for (Node t=tail; t != null && t != node; t=t.prev)     if (t.waitStatus <= 0)     s=t;\n  }\n  if (s != null)   LockSupport.unpark(s.thread);\n}\n", "nl": "Wakes up node's successor, if one exists."}
{"code": "@DSComment(\"From safe class list\") @DSSafe(DSCat.SAFE_LIST) @DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 13:02:44.364 -0500\",hash_original_method=\"EA3734ADDEB20313C9CAB09B48812C54\",hash_generated_method=\"4858AFE909DDE63867ACB561D5449C13\") static public void assertFalse(String message,boolean condition){\n  assertTrue(message,!condition);\n}\n", "nl": "Asserts that a condition is false. If it isn't it throws an AssertionFailedError with the given message."}
{"code": "@Override protected void initData(){\n  Intent intent=new Intent(this,PushMessageService.class);\n  this.startService(intent);\n  this.bindService(intent,this.connection,Context.BIND_AUTO_CREATE);\n}\n", "nl": "Initialize the Activity data"}
{"code": "public static Date parseDateDay(String dateString) throws ParseException {\n  return getSimplDateFormat(DF_DEF).parse(dateString);\n}\n", "nl": "Returns date parsed from string in format: yyyy.MM.dd."}
{"code": "private boolean doesStoragePortExistsInVArray(StoragePort umfsStoragePort,VirtualArray virtualArray){\n  List<URI> virtualArrayPorts=returnAllPortsInVArray(virtualArray.getId());\n  if (virtualArrayPorts.contains(umfsStoragePort.getId())) {\n    return true;\n  }\n  return false;\n}\n", "nl": "Checks if the given storage port is part of VArray"}
{"code": "public SpringVaadinServletService(VaadinServlet servlet,DeploymentConfiguration deploymentConfiguration,String serviceUrl) throws ServiceException {\n  super(servlet,deploymentConfiguration);\n  this.serviceUrl=serviceUrl;\n}\n", "nl": "Create a servlet service instance that allows the use of a custom service URL."}
{"code": "private static List<TranslationResult> translateChildrenOfNode(final ITranslationEnvironment environment,final IOperandTreeNode expression,OperandSize size,final boolean loadOperand,Long baseOffset) throws InternalTranslationException {\n  final List<TranslationResult> partialResults=new ArrayList<>();\n  final List<? extends IOperandTreeNode> children=expression.getChildren();\n  Collections.sort(children,comparator);\n  for (  final IOperandTreeNode child : children) {\n    final TranslationResult nextResult=loadOperand(environment,baseOffset,child,isSegmentExpression(expression.getValue()) ? expression : null,size,loadOperand);\n    partialResults.add(nextResult);\n    baseOffset+=nextResult.getInstructions().size();\n  }\n  return partialResults;\n}\n", "nl": "Iterates over the children of a node in the operand tree and generates translations for them."}
{"code": "public void removeShutdownLatch(final CountDownLatch latch){\n  removeShutdownLatch(latch,false);\n}\n", "nl": "Releases the latch and removes it from the latches being handled by this handler."}
{"code": "public Version(){\n  this(CommonReflection.getVersionTag());\n}\n", "nl": "Constructs a new Version from the current server version running"}
{"code": "public static void startActivity(Context context,String chatId){\n  Intent intent=new Intent(context,SendGroupFile.class);\n  intent.putExtra(EXTRA_CHAT_ID,chatId);\n  context.startActivity(intent);\n}\n", "nl": "Start SendGroupFile activity"}
{"code": "public Index excludedDataCenters(String excludedDataCenters){\n  this.excludedDataCenters=excludedDataCenters;\n  return this;\n}\n", "nl": "Sets the list of excluded data centers."}
{"code": "public final int read() throws IOException {\n  int result=src.read();\n  if (result != -1) {\n    ++pointer;\n  }\n  return result;\n}\n", "nl": "Forwards the request to the real <code>InputStream</code>."}
{"code": "public static boolean compareAndSwapInt(Object obj,long off,int exp,int upd){\n  return UNSAFE.compareAndSwapInt(obj,off,exp,upd);\n}\n", "nl": "Integer CAS."}
{"code": "public static String dec2Bin(int value){\n  String result=\"\";\n  return dec2Bin(value,result);\n}\n", "nl": "Methods converts a decimal number into a binary number as a string"}
{"code": "public void apply(RecyclerView recyclerView,Iterable<Item> items){\n  if (items != null) {\n    HashMap<Integer,Stack<RecyclerView.ViewHolder>> cache=new HashMap<>();\n    for (    Item d : items) {\n      if (!cache.containsKey(d.getType())) {\n        cache.put(d.getType(),new Stack<RecyclerView.ViewHolder>());\n      }\n      if (mCacheSize == -1 || cache.get(d.getType()).size() <= mCacheSize) {\n        cache.get(d.getType()).push(d.getViewHolder(recyclerView));\n      }\n      RecyclerView.RecycledViewPool recyclerViewPool=new RecyclerView.RecycledViewPool();\n      for (      Map.Entry<Integer,Stack<RecyclerView.ViewHolder>> entry : cache.entrySet()) {\n        recyclerViewPool.setMaxRecycledViews(entry.getKey(),mCacheSize);\n        for (        RecyclerView.ViewHolder holder : entry.getValue()) {\n          recyclerViewPool.putRecycledView(holder);\n        }\n        entry.getValue().clear();\n      }\n      cache.clear();\n      recyclerView.setRecycledViewPool(recyclerViewPool);\n    }\n  }\n}\n", "nl": "init the cache on your own."}
{"code": "public void incNumOverflowOnDisk(long delta){\n  this.stats.incLong(numOverflowOnDiskId,delta);\n}\n", "nl": "Increments the current number of entries whose value has been overflowed to disk by a given amount."}
{"code": "public void paint(Graphics a,JComponent b){\n  for (int i=0; i < uis.size(); i++) {\n    ((ComponentUI)(uis.elementAt(i))).paint(a,b);\n  }\n}\n", "nl": "Invokes the <code>paint</code> method on each UI handled by this object."}
{"code": "public void updateUI(){\n  setUI((TableHeaderUI)UIManager.getUI(this));\n  TableCellRenderer renderer=getDefaultRenderer();\n  if (renderer instanceof Component) {\n    SwingUtilities.updateComponentTreeUI((Component)renderer);\n  }\n}\n", "nl": "Notification from the <code>UIManager</code> that the look and feel (L&amp;F) has changed. Replaces the current UI object with the latest version from the <code>UIManager</code>."}
{"code": "public static RefactoringStatus create(IStatus status){\n  if (status.isOK())   return new RefactoringStatus();\n  if (!status.isMultiStatus()) {\nswitch (status.getSeverity()) {\ncase IStatus.OK:\n      return new RefactoringStatus();\ncase IStatus.INFO:\n    return RefactoringStatus.createWarningStatus(status.getMessage());\ncase IStatus.WARNING:\n  return RefactoringStatus.createErrorStatus(status.getMessage());\ncase IStatus.ERROR:\nreturn RefactoringStatus.createFatalErrorStatus(status.getMessage());\ncase IStatus.CANCEL:\nreturn RefactoringStatus.createFatalErrorStatus(status.getMessage());\ndefault :\nreturn RefactoringStatus.createFatalErrorStatus(status.getMessage());\n}\n}\n else {\nIStatus[] children=status.getChildren();\nRefactoringStatus result=new RefactoringStatus();\nfor (int i=0; i < children.length; i++) {\nresult.merge(RefactoringStatus.create(children[i]));\n}\nreturn result;\n}\n}\n", "nl": "Creates a new <code>RefactoringStatus</code> from the given <code>IStatus</code>. An OK status is mapped to an OK refactoring status, an information status is mapped to a warning refactoring status, a warning status is mapped to an error refactoring status and an error or cancel status is mapped to a fatal refactoring status. An unknown status is converted into a fatal error status as well. If the status is a <code>MultiStatus </code> then the first level of children of the status will be added as refactoring status entries to the created refactoring status."}
{"code": "public void debug(String msg){\n  debugLogger.debug(msg);\n}\n", "nl": "Log a Setup and/or administrative log message for log4jdbc."}
{"code": "public int size(){\n  return codon.length;\n}\n", "nl": "Returns the length of the integer codon representation of this grammar."}
{"code": "public Diff decode() throws UnsupportedEncodingException, DecodingException {\n  int header=r.read(3);\n  if (DiffAction.parse(header) != DiffAction.DECODER_DATA) {\n    throw new DecodingException(\"Invalid codecData code: \" + header);\n  }\n  int blockSize_C=3;\n  int blockSize_S=r.read(5);\n  int blockSize_E=r.read(5);\n  int blockSize_B=r.read(5);\n  int blockSize_L=r.read(5);\n  r.read(1);\n  if (blockSize_S < 0 || blockSize_S > 31) {\n    throw new DecodingException(\"blockSize_S out of range: \" + blockSize_S);\n  }\n  if (blockSize_E < 0 || blockSize_E > 31) {\n    throw new DecodingException(\"blockSize_E out of range: \" + blockSize_E);\n  }\n  if (blockSize_B < 0 || blockSize_B > 31) {\n    throw new DecodingException(\"blockSize_B out of range: \" + blockSize_B);\n  }\n  if (blockSize_L < 0 || blockSize_L > 31) {\n    throw new DecodingException(\"blockSize_L out of range: \" + blockSize_L);\n  }\n  return decode(blockSize_C,blockSize_S,blockSize_E,blockSize_B,blockSize_L);\n}\n", "nl": "Decodes the information and returns the Diff."}
{"code": "public FontSizeLocator(){\n}\n", "nl": "Creates a new instance."}
{"code": "@SuppressWarnings({\"unchecked\",\"rawtypes\"}) static <E extends Comparable<E>>AutoSortedCollection<E> createAutoSortedCollection(Collection<? extends E> values){\n  return createAutoSortedCollection(null,values);\n}\n", "nl": "Construct new auto sorted collection using natural order."}
{"code": "@Override public String toString(){\n  return super.toString();\n}\n", "nl": "Returns the super class implementation of toString()."}
{"code": "public boolean useLayoutEditor(SignalMast destination){\n  if (!destList.containsKey(destination)) {\n    return false;\n  }\n  return destList.get(destination).useLayoutEditor();\n}\n", "nl": "Query if we are using the layout editor panels to build the signal mast logic, blocks, turnouts ."}
{"code": "private static String unescapePathComponent(String name){\n  return name.replaceAll(\"\\\\\\\\(.)\",\"$1\");\n}\n", "nl": "Convert a path component that contains backslash escape sequences to a literal string. This is necessary when you want to explicitly refer to a path that contains globber metacharacters."}
{"code": "public AbstractExampleTable(List<Attribute> attributes){\n  addAttributes(attributes);\n}\n", "nl": "Creates a new ExampleTable."}
{"code": "public void zoomOut(){\n  Matrix save=mViewPortHandler.zoomOut(getWidth() / 2f,-(getHeight() / 2f));\n  mViewPortHandler.refresh(save,this,true);\n}\n", "nl": "Zooms out by 0.7f, from the charts center. center."}
{"code": "public Media createBackgroundMedia(String uri) throws IOException {\n  return impl.createBackgroundMedia(uri);\n}\n", "nl": "Creates an audio media that can be played in the background."}
{"code": "private boolean hasNextTlsMode(){\n  return nextTlsMode != TLS_MODE_NULL;\n}\n", "nl": "Returns true if there's another TLS mode to try."}
{"code": "protected void copyToOpsw(){\n  opsw[1]=fullmode.isSelected();\n  opsw[2]=twoaspects.isSelected();\n  opsw[11]=semaphore.isSelected();\n  opsw[12]=pulsed.isSelected();\n  opsw[13]=disableDS.isSelected();\n  opsw[14]=fromloconet.isSelected();\n  opsw[15]=disablelocal.isSelected();\n  opsw[17]=sigaddress.isSelected();\n  opsw[18]=bcastaddress.isSelected();\n  opsw[19]=semaddress.isSelected();\n  opsw[20]=setdefault.isSelected();\n  opsw[21]=exercise.isSelected();\n  int value=section1to4mode.getSelectedIndex();\n  if ((value & 0x01) != 0) {\n    opsw[5]=true;\n  }\n else {\n    opsw[5]=false;\n  }\n  if ((value & 0x02) != 0) {\n    opsw[4]=true;\n  }\n else {\n    opsw[4]=false;\n  }\n  if ((value & 0x04) != 0) {\n    opsw[3]=true;\n  }\n else {\n    opsw[3]=false;\n  }\n  value=section5to8mode.getSelectedIndex();\n  if ((value & 0x01) != 0) {\n    opsw[8]=true;\n  }\n else {\n    opsw[8]=false;\n  }\n  if ((value & 0x02) != 0) {\n    opsw[7]=true;\n  }\n else {\n    opsw[7]=false;\n  }\n  if ((value & 0x04) != 0) {\n    opsw[6]=true;\n  }\n else {\n    opsw[6]=false;\n  }\n  value=fourthAspect.getSelectedIndex();\n  if ((value & 0x01) != 0) {\n    opsw[10]=true;\n  }\n else {\n    opsw[10]=false;\n  }\n  if ((value & 0x02) != 0) {\n    opsw[9]=true;\n  }\n else {\n    opsw[9]=false;\n  }\n}\n", "nl": "Copy from the GUI to the opsw array. <p> Used before write operations start"}
{"code": "@Override public void onRequestPermissionsResult(int requestCode,@NonNull String[] permissions,@NonNull int[] grantResults){\n  if (requestCode == ALLOW_PERMISSIONS && grantResults.length > 0) {\n    List<String> permissionsNotAllowed=new ArrayList<>();\n    for (int i=0; i < permissions.length; i++) {\n      if (grantResults[i] == PackageManager.PERMISSION_DENIED) {\n        permissionsNotAllowed.add(permissions[i]);\n      }\n    }\n    if (permissionsNotAllowed.isEmpty()) {\n      initEvent();\n    }\n else {\n      permissionNotEnabled();\n    }\n  }\n else {\n    permissionNotEnabled();\n  }\n}\n", "nl": "This method is a callback. Check the user's answer after requesting permission."}
{"code": "public String rowGet(String key){\n  String resolvedKey=resolveRowKey(key);\n  String cachedValue=rowMapCache.get(resolvedKey);\n  if (cachedValue != null) {\n    return cachedValue;\n  }\n  String value=rowMap.get(resolvedKey);\n  if (value == null && parent != null) {\n    value=parent.rowGet(resolvedKey);\n  }\n  if (value == null) {\n    return null;\n  }\n  String expandedString=expand(value,false);\n  rowMapCache.put(resolvedKey,expandedString);\n  return expandedString;\n}\n", "nl": "Looks up and returns the RowSpec associated with the given key. First looks for an association in this LayoutMap. If there's no association, the lookup continues with the parent map - if any."}
{"code": "public void postEvaluationStatistics(final EvolutionState state){\n  super.postEvaluationStatistics(state);\n  state.output.println(\"\\nGeneration: \" + state.generation,Output.V_NO_GENERAL,statisticslog);\n  for (int x=0; x < state.population.subpops.length; x++)   for (int y=1; y < state.population.subpops[x].individuals.length; y++)   state.population.subpops[x].individuals[y].printIndividualForHumans(state,statisticslog,Output.V_NO_GENERAL);\n}\n", "nl": "Logs the best individual of the generation."}
{"code": "private void checkUserExists(String entidad) throws Exception {\n  int count;\n  UsersTable table=new UsersTable();\n  DbConnection dbConn=new DbConnection();\n  try {\n    dbConn.open(DBSessionManager.getSession());\n    if (_id == ISicresAdminDefsKeys.NULL_ID)     count=DbSelectFns.selectCount(dbConn,table.getBaseTableName(),table.getCountNameQual(_name));\n else     count=DbSelectFns.selectCount(dbConn,table.getBaseTableName(),table.getCountNameIdQual(_id,_name));\n    if (count > 0)     ISicresAdminBasicException.throwException(ISicresAdminUserKeys.EC_USER_EXISTS_NAME);\n  }\n catch (  Exception e) {\n    _logger.error(e);\n    throw e;\n  }\n finally {\n    dbConn.close();\n  }\n}\n", "nl": "Comprueba que el usuario tiene distinto nombre a los que ya existen."}
{"code": "@Transactional public Role createRoleWithPermissions(Role role,Set<Long> permissionIds){\n  Role current=findRoleByRoleName(role.getRoleName());\n  Preconditions.checkState(current == null,\"Role %s already exists!\",role.getRoleName());\n  Role createdRole=roleRepository.save(role);\n  if (!CollectionUtils.isEmpty(permissionIds)) {\n    Iterable<RolePermission> rolePermissions=FluentIterable.from(permissionIds).transform(null);\n    rolePermissionRepository.save(rolePermissions);\n  }\n  return createdRole;\n}\n", "nl": "Create role with permissions, note that role name should be unique"}
{"code": "protected void generateNewCursorBox(){\n  if ((old_m_x2 != -1) || (old_m_y2 != -1) || (Math.abs(commonValues.m_x2 - old_m_x2) > 5)|| (Math.abs(commonValues.m_y2 - old_m_y2) > 5)) {\n    int top_x=commonValues.m_x1;\n    if (commonValues.m_x1 > commonValues.m_x2) {\n      top_x=commonValues.m_x2;\n    }\n    int top_y=commonValues.m_y1;\n    if (commonValues.m_y1 > commonValues.m_y2) {\n      top_y=commonValues.m_y2;\n    }\n    final int w=Math.abs(commonValues.m_x2 - commonValues.m_x1);\n    final int h=Math.abs(commonValues.m_y2 - commonValues.m_y1);\n    final int[] currentRectangle={top_x,top_y,w,h};\n    decode_pdf.updateCursorBoxOnScreen(currentRectangle,DecoderOptions.highlightColor.getRGB());\n    if (!currentCommands.extractingAsImage) {\n      final int[] r={commonValues.m_x1,commonValues.m_y1,commonValues.m_x2 - commonValues.m_x1,commonValues.m_y2 - commonValues.m_y1};\n      decode_pdf.getTextLines().addHighlights(new int[][]{r},false,commonValues.getCurrentPage());\n    }\n    old_m_x2=commonValues.m_x2;\n    old_m_y2=commonValues.m_y2;\n  }\n  decode_pdf.repaintPane(commonValues.getCurrentPage());\n}\n", "nl": "generate new  cursorBox and highlight extractable text, if hardware acceleration off and extraction on<br> and update current cursor box displayed on screen"}
{"code": "public OMGraphicList(int initialCapacity){\n  graphics=Collections.synchronizedList(new ArrayList<OMGraphic>(initialCapacity));\n}\n", "nl": "Construct an OMGraphicList with an initial capacity."}
{"code": "private void saveToSettings(){\n  List<String> dataToSave=new LinkedList<>();\n  for (  UsercolorItem item : data) {\n    dataToSave.add(item.getId() + \",\" + HtmlColors.getColorString(item.getColor()));\n  }\n  settings.putList(\"usercolors\",dataToSave);\n}\n", "nl": "Copy the current data to the settings."}
{"code": "public static boolean isArrayForName(String value){\n  return ARRAY_FOR_NAME_PATTERN.matcher(value).matches();\n}\n", "nl": "Returns true if the given string looks like a Java array name."}
{"code": "public double length(){\n  return Math.sqrt(this.x * this.x + this.y * this.y);\n}\n", "nl": "Calculates the length of the vector."}
{"code": "public String toString(){\n  return schema;\n}\n", "nl": "Returns this' media-type (a MIME content-type category) (previously returned a description key)"}
{"code": "public void restoreStarting(int numPackages){\n}\n", "nl": "The restore operation has begun."}
{"code": "private boolean resourceIsGwtXmlAndInGwt(IResource resource) throws CoreException {\n  return GWTNature.isGWTProject(resource.getProject()) && resource.getName().endsWith(\".gwt.xml\");\n}\n", "nl": "If the resource is a .gwt.xml file and we're in a gwt-enabled project, return true."}
{"code": "public GlowCreature(Location location,EntityType type,double maxHealth){\n  super(location,maxHealth);\n  this.type=type;\n}\n", "nl": "Creates a new monster."}
{"code": "public CacheLayer(){\n}\n", "nl": "Construct a default CacheLayer."}
{"code": "protected Address buildAndroidAddress(JSONObject jResult) throws JSONException {\n  Address gAddress=new Address(mLocale);\n  gAddress.setLatitude(jResult.getDouble(\"lat\"));\n  gAddress.setLongitude(jResult.getDouble(\"lng\"));\n  int addressIndex=0;\n  if (jResult.has(\"streetName\")) {\n    gAddress.setAddressLine(addressIndex++,jResult.getString(\"streetName\"));\n    gAddress.setThoroughfare(jResult.getString(\"streetName\"));\n  }\n  if (jResult.has(\"zipCode\")) {\n    gAddress.setAddressLine(addressIndex++,jResult.getString(\"zipCode\"));\n    gAddress.setPostalCode(jResult.getString(\"zipCode\"));\n  }\n  if (jResult.has(\"city\")) {\n    gAddress.setAddressLine(addressIndex++,jResult.getString(\"city\"));\n    gAddress.setLocality(jResult.getString(\"city\"));\n  }\n  if (jResult.has(\"state\")) {\n    gAddress.setAdminArea(jResult.getString(\"state\"));\n  }\n  if (jResult.has(\"country\")) {\n    gAddress.setAddressLine(addressIndex++,jResult.getString(\"country\"));\n    gAddress.setCountryName(jResult.getString(\"country\"));\n  }\n  if (jResult.has(\"countrycode\"))   gAddress.setCountryCode(jResult.getString(\"countrycode\"));\n  return gAddress;\n}\n", "nl": "Build an Android Address object from the Gisgraphy address in JSON format."}
{"code": "public JDBCCategoryDataset(Connection connection,String query) throws SQLException {\n  this(connection);\n  executeQuery(query);\n}\n", "nl": "Creates a new dataset with the given database connection, and executes the supplied query to populate the dataset."}
{"code": "private void readObject(ObjectInputStream s) throws IOException, ClassNotFoundException {\n  s.defaultReadObject();\n  if (bayesIm == null) {\n    throw new NullPointerException();\n  }\n  if (variables == null) {\n    throw new NullPointerException();\n  }\n}\n", "nl": "Adds semantic checks to the default deserialization method. This method must have the standard signature for a readObject method, and the body of the method must begin with \"s.defaultReadObject();\". Other than that, any semantic checks can be specified and do not need to stay the same from version to version. A readObject method of this form may be added to any class, even if Tetrad sessions were previously saved out using a version of the class that didn't include it. (That's what the \"s.defaultReadObject();\" is for. See J. Bloch, Effective Java, for help."}
{"code": "boolean contains(ProtocolVersion protocolVersion){\n  if (protocolVersion == ProtocolVersion.SSL20Hello) {\n    return false;\n  }\n  return protocols.contains(protocolVersion);\n}\n", "nl": "Return whether this list contains the specified protocol version. SSLv2Hello is not a real protocol version we support, we always return false for it."}
{"code": "@Override protected EClass eStaticClass(){\n  return DatatypePackage.Literals.OBJECT_PROPERTY_TYPE;\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "@DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 12:34:35.806 -0500\",hash_original_method=\"E14DF72F5869874CC38AD67447F5264E\",hash_generated_method=\"127365361841BB38033FE96228DFD635\") public final Iterator<String> typesIterator(){\n  return mDataTypes != null ? mDataTypes.iterator() : null;\n}\n", "nl": "Return an iterator over the filter's data types."}
{"code": "public void registerGUI(final ConfigGUI gui){\n  this.gui=gui;\n}\n", "nl": "Sets the reference of the GUI."}
{"code": "public IntersectionMatrix(IntersectionMatrix other){\n  this();\n  matrix[Location.INTERIOR][Location.INTERIOR]=other.matrix[Location.INTERIOR][Location.INTERIOR];\n  matrix[Location.INTERIOR][Location.BOUNDARY]=other.matrix[Location.INTERIOR][Location.BOUNDARY];\n  matrix[Location.INTERIOR][Location.EXTERIOR]=other.matrix[Location.INTERIOR][Location.EXTERIOR];\n  matrix[Location.BOUNDARY][Location.INTERIOR]=other.matrix[Location.BOUNDARY][Location.INTERIOR];\n  matrix[Location.BOUNDARY][Location.BOUNDARY]=other.matrix[Location.BOUNDARY][Location.BOUNDARY];\n  matrix[Location.BOUNDARY][Location.EXTERIOR]=other.matrix[Location.BOUNDARY][Location.EXTERIOR];\n  matrix[Location.EXTERIOR][Location.INTERIOR]=other.matrix[Location.EXTERIOR][Location.INTERIOR];\n  matrix[Location.EXTERIOR][Location.BOUNDARY]=other.matrix[Location.EXTERIOR][Location.BOUNDARY];\n  matrix[Location.EXTERIOR][Location.EXTERIOR]=other.matrix[Location.EXTERIOR][Location.EXTERIOR];\n}\n", "nl": "Creates an <code>IntersectionMatrix</code> with the same elements as <code>other</code>."}
{"code": "public long readUnsignedInt(){\n  long result=shiftIntoLong(data,position,4);\n  position+=4;\n  return result;\n}\n", "nl": "Reads the next four bytes as an unsigned value."}
{"code": "public void emit(final SpannableStringBuilder out,final Block root){\n  root.removeSurroundingEmptyLines();\nswitch (root.type) {\ncase NONE:\n    break;\ncase PARAGRAPH:\n  this.config.decorator.openParagraph(out);\nbreak;\ncase BLOCKQUOTE:\nthis.config.decorator.openBlockquote(out);\nbreak;\ncase UNORDERED_LIST:\nthis.config.decorator.openUnorderedList(out);\nbreak;\ncase ORDERED_LIST:\nthis.config.decorator.openOrderedList(out);\nbreak;\ncase UNORDERED_LIST_ITEM:\nthis.config.decorator.openUnOrderedListItem(out);\nbreak;\ncase ORDERED_LIST_ITEM:\nthis.config.decorator.openOrderedListItem(out);\nbreak;\n}\nif (root.hasLines()) {\nthis.emitLines(out,root);\n}\n else {\nBlock block=root.blocks;\nwhile (block != null) {\nthis.emit(out,block);\nblock=block.next;\n}\n}\nswitch (root.type) {\ncase NONE:\nbreak;\ncase PARAGRAPH:\nthis.config.decorator.closeParagraph(out);\nbreak;\ncase BLOCKQUOTE:\nthis.config.decorator.closeBlockquote(out);\nbreak;\ncase UNORDERED_LIST:\nthis.config.decorator.closeUnorderedList(out);\nbreak;\ncase ORDERED_LIST:\nthis.config.decorator.closeOrderedList(out);\nbreak;\ncase UNORDERED_LIST_ITEM:\nthis.config.decorator.closeUnOrderedListItem(out);\nbreak;\ncase ORDERED_LIST_ITEM:\nthis.config.decorator.closeOrderedListItem(out);\nbreak;\n}\n}\n", "nl": "Transforms the given block recursively into HTML."}
{"code": "public boolean isInternable(){\n  return (classAnnotations != null) && (fieldAnnotations == null) && (methodAnnotations == null)&& (parameterAnnotations == null);\n}\n", "nl": "Returns whether this item is a candidate for interning. The only interning candidates are ones that <i>only</i> have a non-null set of class annotations, with no other lists."}
{"code": "public URI(final String scheme,final String userinfo,final String host,final int port,final String path,final String query,final String fragment) throws URIException {\n  this(scheme,(host == null) ? null : ((userinfo != null) ? userinfo + '@' : \"\") + host + ((port != -1) ? \":\" + port : \"\"),path,query,fragment);\n}\n", "nl": "Construct a general URI from the given components."}
{"code": "public void addUser(User user){\n  users.addElement(user);\n}\n", "nl": "Add a user"}
{"code": "protected void engineUpdate(byte b) throws SignatureException {\n  msgDigest.update(b);\n}\n", "nl": "Updates data to sign or to verify."}
{"code": "public RqMtFake(final Request req,final Request... dispositions) throws IOException {\n  this.fake=new RqMtBase(new RqMtFake.FakeMultipartRequest(req,dispositions));\n}\n", "nl": "Fake ctor."}
{"code": "public static Video randomVideo(){\n  String id=UUID.randomUUID().toString();\n  String title=\"Video-\" + id;\n  String url=\"http://coursera.org/some/video-\" + id;\n  long duration=60 * (int)Math.rint(Math.random() * 60) * 1000;\n  return new Video(title,url,duration);\n}\n", "nl": "Construct and return a Video object with a rnadom name, url, and duration."}
{"code": "public void addHeader(String header,String value){\n  clientHeaderMap.put(header,value);\n}\n", "nl": "Sets headers that will be added to all requests this client makes (before sending)."}
{"code": "public void addPostalAddress(PostalAddress postalAddress){\n  getPostalAddresses().add(postalAddress);\n}\n", "nl": "Adds a new contact postal address."}
{"code": "public CaughtExceptionRef newCaughtExceptionRef(){\n  return new JCaughtExceptionRef();\n}\n", "nl": "Constructs a CaughtExceptionRef() grammar chunk."}
{"code": "public void actionPerformed(ActionEvent e){\n  if (e.getSource() instanceof PerformanceIndicator) {\n    PerformanceIndicator pi=(PerformanceIndicator)e.getSource();\n    log.info(pi.getName());\n    MGoal goal=pi.getGoal();\n    if (goal.getMeasure() != null)     new PerformanceDetail(goal);\n  }\n}\n", "nl": "Action Listener for Drill Down"}
{"code": "public Iterator<AbstractNode> childIterator(final boolean dirtyNodesOnly){\n  if (dirtyNodesOnly) {\n    return new DirtyChildIterator(this);\n  }\n else {\n    return new ChildIterator(this);\n  }\n}\n", "nl": "Iterator visits the direct child nodes in the external key ordering."}
{"code": "public static int maxIndex(double[] doubles){\n  double maximum=0;\n  int maxIndex=0;\n  for (int i=0; i < doubles.length; i++) {\n    if ((i == 0) || (doubles[i] > maximum)) {\n      maxIndex=i;\n      maximum=doubles[i];\n    }\n  }\n  return maxIndex;\n}\n", "nl": "Returns index of maximum element in a given array of doubles. First maximum is returned."}
{"code": "@Inline private static void genNullCheck(Assembler asm,GPR objRefReg){\n  asm.emitTEST_Reg_Reg(objRefReg,objRefReg);\n  asm.emitBranchLikelyNextInstruction();\n  ForwardReference fr=asm.forwardJcc(NE);\n  asm.emitINT_Imm(RuntimeEntrypoints.TRAP_NULL_POINTER + RVM_TRAP_BASE);\n  fr.resolve(asm);\n}\n", "nl": "Generate an explicit null check (compare to zero)."}
{"code": "public Location(String provider){\n  mProvider=provider;\n}\n", "nl": "Construct a new Location with a named provider. <p>By default time, latitude and longitude are 0, and the location has no bearing, altitude, speed, accuracy or extras."}
{"code": "public NodesInfoRequest(String... nodesIds){\n  super(nodesIds);\n}\n", "nl": "Get information from nodes based on the nodes ids specified. If none are passed, information for all nodes will be returned."}
{"code": "public static double norm(double[] a){\n  double squaredSum=0;\n  for (int i=0; i < a.length; i++) {\n    squaredSum+=a[i] * a[i];\n  }\n  return Math.sqrt(squaredSum);\n}\n", "nl": "Computes 2-norm of vector"}
{"code": "private static double[] toDoubleAray(Integer[] intArray,HashSet<Integer> skipIndex){\n  double[] res=new double[intArray.length - skipIndex.size()];\n  int skip=0;\n  for (int i=0; i < intArray.length; i++) {\n    if (skipIndex.contains(i)) {\n      skip++;\n      continue;\n    }\n    res[i - skip]=intArray[i].doubleValue();\n  }\n  return res;\n}\n", "nl": "Converts an array into array of doubles skipping specified indeces."}
{"code": "private void updateProgress(String progressLabel,int progress){\n  if (myHost != null && ((progress != previousProgress) || (!progressLabel.equals(previousProgressLabel)))) {\n    myHost.updateProgress(progressLabel,progress);\n  }\n  previousProgress=progress;\n  previousProgressLabel=progressLabel;\n}\n", "nl": "Used to communicate a progress update between a plugin tool and the main Whitebox user interface."}
{"code": "public CompositeValidationIssueProcessor(final IValidationIssueProcessor first,final IValidationIssueProcessor... others){\n  processors=Lists.asList(first,others);\n}\n", "nl": "Creates a new composite issue processor with the given sub processor arguments."}
{"code": "public OptionSet removeMaxAge(){\n  max_age=null;\n  return this;\n}\n", "nl": "Removes the Max-Age option. Returns the current OptionSet object for a fluent API."}
{"code": "public Request(){\n  locality=\"\";\n  state=\"\";\n  organization=\"\";\n  orgunit=\"\";\n  dnsname=\"\";\n  uri=\"\";\n  email=\"\";\n  ipaddress=\"\";\n  keyusage=0;\n}\n", "nl": "Ctor for the Request Object"}
{"code": "@Override protected Position determineMainLabelPosition(DrawContext dc){\n  return this.getReferencePosition();\n}\n", "nl": "Compute the position for the area's main label. This position indicates the position of the first line of the label. If there are more lines, they will be arranged South of the first line."}
{"code": "@Override Map<String,Object> extractFields(String line){\n  if (!initialized) {\n    init();\n    initialized=true;\n  }\n  String[] values=fixedWidthParser.parseLine(line);\n  if (hasHeader && Arrays.deepEquals(values,header)) {\n    return null;\n  }\n  Map<String,Object> map=Maps.newHashMap();\n  int i=0;\n  for (  FixedWidthField field : fields) {\n    map.put(field.getName(),getValue(field,values[i++]));\n  }\n  return map;\n}\n", "nl": "Extracts the fields from a fixed width record and returns a map containing field names and values"}
{"code": "@Override public boolean contains(Value subvalue){\n  return toString().contains(subvalue.toString());\n}\n", "nl": "Returns true if the value is contained in the relation structure. (this is done"}
{"code": "private void applyTo(ClassVisitor v,Field f){\n  if (Log.isLoggingOn()) {\n    Log.logLine(String.format(\"Visiting field %s\",f.toGenericString()));\n  }\n  v.visit(f);\n}\n", "nl": "Apply a visitor to a field."}
{"code": "@Override protected EClass eStaticClass(){\n  return ExpressionsPackage.Literals.BITWISE_AND_EXPRESSION;\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "@Override public final void closePath(){\n  shape_primitives.addElement(H);\n  shape_primitive_x.addElement(0);\n  shape_primitive_y.addElement(0);\n  shape_primitive_x2.addElement(0);\n  shape_primitive_y2.addElement(0);\n  shape_primitive_x3.addElement(0);\n  shape_primitive_y3.addElement(0);\n}\n", "nl": "end a shape, storing info for later"}
{"code": "public DefaultBoundValueOperations(K key,RedisOperations<K,V> operations){\n  super(key,operations);\n  this.ops=operations.opsForValue();\n}\n", "nl": "Constructs a new <code>DefaultBoundValueOperations</code> instance."}
{"code": "@Override public void writeBatch() throws IOException {\n  if (getInstances() == null) {\n    throw new IOException(\"No instances to save\");\n  }\n  if (getRetrieval() == INCREMENTAL) {\n    throw new IOException(\"Batch and incremental saving cannot be mixed.\");\n  }\n  setRetrieval(BATCH);\n  setWriteMode(WRITE);\n  if ((retrieveFile() == null) && (getWriter() == null)) {\n    for (int i=0; i < getInstances().numInstances(); i++) {\n      System.out.println(instanceToLibsvm(getInstances().instance(i)));\n    }\n    setWriteMode(WAIT);\n  }\n else {\n    PrintWriter outW=new PrintWriter(getWriter());\n    for (int i=0; i < getInstances().numInstances(); i++) {\n      outW.println(instanceToLibsvm(getInstances().instance(i)));\n    }\n    outW.flush();\n    outW.close();\n    setWriteMode(WAIT);\n    outW=null;\n    resetWriter();\n    setWriteMode(CANCEL);\n  }\n}\n", "nl": "Writes a Batch of instances"}
{"code": "public FloatMatrix truthi(){\n  for (int i=0; i < length; i++) {\n    put(i,get(i) == 0.0f ? 0.0f : 1.0f);\n  }\n  return this;\n}\n", "nl": "Maps zero to 0.0 and all non-zero values to 1.0 (in-place)."}
{"code": "public void testCallProcEscapeSequenceWithWhitespaces() throws Exception {\n  check(\"CALL func1()\",\"{ call func1()}\");\n  check(\"CALL func1()\",\"{    call  func1()}\");\n  check(\"CALL func1()\",\"{ \\n call\\nfunc1()}\");\n  checkFail(\"{ \\n func1()}\");\n}\n", "nl": "Test escape sequences with additional whitespace characters"}
{"code": "public EnumRowStatus(Long valueIndex) throws IllegalArgumentException {\n  this(valueIndex.longValue());\n}\n", "nl": "Build an <code>EnumRowStatus</code> from a <code>Long</code>."}
{"code": "public static void putbytes2Uint8s(char[] destUint8s,byte[] srcBytes,int destOffset,int srcOffset,int count){\n  for (int i=0; i < count; i++) {\n    destUint8s[destOffset + i]=convertByte2Uint8(srcBytes[srcOffset + i]);\n  }\n}\n", "nl": "Put byte[] into char[]( we treat char[] as uint8[])"}
{"code": "public static void superposeWithAngle(ComplexVector vec1,ComplexVector vec2,float weight,int[] permutation){\n  int positionToAdd;\n  int dim=vec1.getDimension();\n  short c[]=vec2.getPhaseAngles();\n  float[] coordinates=vec1.getCoordinates();\n  if (permutation != null) {\n    for (int i=0; i < dim; i++) {\n      positionToAdd=permutation[i] << 1;\n      coordinates[positionToAdd]+=CircleLookupTable.getRealEntry(c[i]) * weight;\n      coordinates[positionToAdd + 1]+=CircleLookupTable.getImagEntry(c[i]) * weight;\n    }\n  }\n else {\n    for (int i=0; i < dim; i++) {\n      positionToAdd=i << 1;\n      coordinates[positionToAdd]+=CircleLookupTable.getRealEntry(c[i]) * weight;\n      coordinates[positionToAdd + 1]+=CircleLookupTable.getImagEntry(c[i]) * weight;\n    }\n  }\n}\n", "nl": "Superposes vec2 with vec1 with weight and permutation. vec1 is in CARTESIAN mode. vec2 is in POLAR mode."}
{"code": "protected void _addFieldMixIns(Class<?> targetClass,Class<?> mixInCls,Map<String,AnnotatedField> fields){\n  List<Class<?>> parents=new ArrayList<Class<?>>();\n  parents.add(mixInCls);\n  ClassUtil.findSuperTypes(mixInCls,targetClass,parents);\n  for (  Class<?> mixin : parents) {\n    for (    Field mixinField : mixin.getDeclaredFields()) {\n      if (!_isIncludableField(mixinField)) {\n        continue;\n      }\n      String name=mixinField.getName();\n      AnnotatedField maskedField=fields.get(name);\n      if (maskedField != null) {\n        for (        Annotation a : mixinField.getDeclaredAnnotations()) {\n          if (_annotationIntrospector.isHandled(a)) {\n            maskedField.addOrOverride(a);\n          }\n        }\n      }\n    }\n  }\n}\n", "nl": "Method called to add field mix-ins from given mix-in class (and its fields) into already collected actual fields (from introspected classes and their super-classes)"}
{"code": "@Override public boolean input(Instance instance) throws Exception {\n  if (getInputFormat() == null) {\n    throw new IllegalStateException(\"No input instance format defined\");\n  }\n  if (m_NewBatch) {\n    resetQueue();\n    m_NewBatch=false;\n  }\n  double[] vals=new double[instance.numAttributes() + 1];\n  for (int i=0; i < instance.numAttributes(); i++) {\n    if (instance.isMissing(i)) {\n      vals[i]=Utils.missingValue();\n    }\n else {\n      vals[i]=instance.value(i);\n    }\n  }\n  m_attributeExpression.evaluateExpression(vals);\n  Instance inst=null;\n  if (instance instanceof SparseInstance) {\n    inst=new SparseInstance(instance.weight(),vals);\n  }\n else {\n    inst=new DenseInstance(instance.weight(),vals);\n  }\n  inst.setDataset(getOutputFormat());\n  copyValues(inst,false,instance.dataset(),getOutputFormat());\n  inst.setDataset(getOutputFormat());\n  push(inst);\n  return true;\n}\n", "nl": "Input an instance for filtering. Ordinarily the instance is processed and made available for output immediately. Some filters require all instances be read before producing output."}
{"code": "public String lookup(String data){\n  Iterator<String> it=map.getPrefixedBy(data);\n  if (!it.hasNext())   return null;\n  return it.next();\n}\n", "nl": "Return the last String in the set that can be prefixed by this String (Trie's are stored in alphabetical order). Return null if no such String exist in the current set."}
{"code": "public boolean attempt(LiveAnalysis live,Register r1,Register r2){\n  if (isLiveAtDef(r2,r1,live))   return false;\n  if (isLiveAtDef(r1,r2,live))   return false;\n  if (split(r1,r2))   return false;\n  if (r1 == r2)   return false;\n  live.merge(r1,r2);\n  for (Enumeration<RegisterOperand> e=DefUse.defs(r2); e.hasMoreElements(); ) {\n    RegisterOperand def=e.nextElement();\n    DefUse.removeDef(def);\n    def.setRegister(r1);\n    DefUse.recordDef(def);\n  }\n  for (Enumeration<RegisterOperand> e=DefUse.uses(r2); e.hasMoreElements(); ) {\n    RegisterOperand use=e.nextElement();\n    DefUse.removeUse(use);\n    use.setRegister(r1);\n    DefUse.recordUse(use);\n  }\n  return true;\n}\n", "nl": "Attempt to coalesce register r2 into register r1.  If this is legal, <ul> <li> rewrite all defs and uses of r2 as defs and uses of r1 <li> update the liveness information <li> update the def-use chains </ul> <strong>PRECONDITION </strong> def-use chains must be computed and valid."}
{"code": "private void registerTarget(final Message message,final String virtualHost){\n  final String thingId=getStringHeaderKey(message,MessageHeaderKey.THING_ID,\"ThingId is null\");\n  final String replyTo=message.getMessageProperties().getReplyTo();\n  if (StringUtils.isEmpty(replyTo)) {\n    logAndThrowMessageError(message,\"No ReplyTo was set for the createThing Event.\");\n  }\n  final URI amqpUri=IpUtil.createAmqpUri(virtualHost,replyTo);\n  final Target target=controllerManagement.findOrRegisterTargetIfItDoesNotexist(thingId,amqpUri);\n  LOG.debug(\"Target {} reported online state.\",thingId);\n  lookIfUpdateAvailable(target);\n}\n", "nl": "Method to create a new target or to find the target if it already exists."}
{"code": "private void returnData(Object ret){\n  if (myHost != null) {\n    myHost.returnData(ret);\n  }\n}\n", "nl": "Used to communicate a return object from a plugin tool to the main Whitebox user-interface."}
{"code": "public long term(){\n  return term;\n}\n", "nl": "Returns the responding node's current term."}
{"code": "public void purgePlayer(Player player){\n  zombies.remove(player.getUniqueId());\n  humans.remove(player.getUniqueId());\n}\n", "nl": "Removes the player from the current ADTs."}
{"code": "public RestClient(String target,String username,String password,CloseableHttpAsyncClient asyncClient){\n  checkNotNull(target,\"target cannot be null\");\n  checkNotNull(username,\"username cannot be null\");\n  checkNotNull(password,\"password cannot be null\");\n  this.target=target;\n  this.clientContext=getHttpClientContext(target,username,password);\n  this.asyncClient=asyncClient == null ? getHttpClient() : asyncClient;\n}\n", "nl": "Constructs a RestClient."}
{"code": "private String createPatternHash(int baseColorIndex){\n  String hashSource=\"\" + baseColorIndex + \"\";\n  int count=0;\nsynchronized (PatternList) {\n    for (    BannerPattern bp : PatternList) {\n      if (count++ != 0) {\n        hashSource+=\"-\";\n      }\n      hashSource+=bp.toString();\n    }\n  }\n  return hashSource;\n}\n", "nl": "Creates a uniq string for combination of patterns"}
{"code": "public void close() throws IOException {\n  super.close();\n  disposerRecord.dispose();\n  stream=null;\n  cache=null;\n  cacheFile=null;\n  StreamCloser.removeFromQueue(closeAction);\n}\n", "nl": "Closes this <code>FileCacheImageInputStream</code>, closing and removing the cache file.  The source <code>InputStream</code> is not closed."}
{"code": "public static Uri importContent(String sessionId,String sourcePath) throws IOException {\n  File sourceFile=new File(sourcePath);\n  String targetPath=\"/\" + sessionId + \"/upload/\"+ sourceFile.getName();\n  targetPath=createUniqueFilename(targetPath);\n  copyToVfs(sourcePath,targetPath);\n  return vfsUri(targetPath);\n}\n", "nl": "Copy device content into vfs. All imported content is stored under /SESSION_NAME/ The original full path is retained to facilitate browsing The session content can be deleted when the session is over"}
{"code": "public static ProjectActionEvent createProjectClosedEvent(ProjectDescriptor project,boolean closingBeforeOpening){\n  return new ProjectActionEvent(project,ProjectAction.CLOSED,closingBeforeOpening);\n}\n", "nl": "Creates a Project Closed Event."}
{"code": "public static void initiateItemEvent(EntityPlayer player,ItemStack itemStack,int event,boolean limitRange){\n  try {\n    if (NetworkManager_initiateItemEvent == null)     NetworkManager_initiateItemEvent=Class.forName(getPackage() + \".core.network.NetworkManager\").getMethod(\"initiateItemEvent\",EntityPlayer.class,ItemStack.class,Integer.TYPE,Boolean.TYPE);\n    if (instance == null)     instance=getInstance();\n    NetworkManager_initiateItemEvent.invoke(instance,player,itemStack,event,limitRange);\n  }\n catch (  Exception e) {\n    throw new RuntimeException(e);\n  }\n}\n", "nl": "Immediately send an event for the specified Item to the clients in range. The item should implement INetworkItemEventListener to receive the event. If this method is being executed on the client (i.e. Singleplayer), it'll just call INetworkItemEventListener.onNetworkEvent (if implemented by the item)."}
{"code": "public Enumeration<V> elements(){\n  return new ValueIterator();\n}\n", "nl": "Returns an enumeration of the values in this table."}
{"code": "private boolean trackerAt(StendhalRPZone zone,int x,int y){\n  final List<Entity> list=zone.getEntitiesAt(x,y);\n  for (  Entity entity : list) {\n    if (entity instanceof ExpirationTracker) {\n      return true;\n    }\n  }\n  return false;\n}\n", "nl": "Checks to see if an ExpirationTracker is already at a given coordinate to prevent multiple one from accumulating in the database"}
{"code": "public Segment segment(long index){\n  assertOpen();\n  if (currentSegment != null && currentSegment.validIndex(index))   return currentSegment;\n  Map.Entry<Long,Segment> segment=segments.floorEntry(index);\n  return segment != null ? segment.getValue() : null;\n}\n", "nl": "Returns the segment for the given index."}
{"code": "@DSSafe(DSCat.SAFE_LIST) @DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2014-09-03 15:01:20.138 -0400\",hash_original_method=\"5CC57CD7C5B9408E54C315A9BE16050C\",hash_generated_method=\"E0C143C4A578FB33A41B66D46278449D\") public int nextInt(int least,int bound){\n  if (least >= bound)   throw new IllegalArgumentException();\n  return nextInt(bound - least) + least;\n}\n", "nl": "Returns a pseudorandom, uniformly distributed value between the given least value (inclusive) and bound (exclusive)."}
{"code": "protected ECPoint multiplyPositive(ECPoint p,BigInteger k){\n  ECPoint[] R=new ECPoint[]{p.getCurve().getInfinity(),p};\n  int n=k.bitLength();\n  for (int i=0; i < n; ++i) {\n    int b=k.testBit(i) ? 1 : 0;\n    int bp=1 - b;\n    R[bp]=R[bp].twicePlus(R[b]);\n  }\n  return R[0];\n}\n", "nl": "Joye's double-add algorithm."}
{"code": "void listItemsSortedSecure() throws Exception {\n  System.out.println(\"Secure Systems Inc. - list items\");\n  String order=input(\"order (id, name)?\");\n  if (!order.matches(\"[a-zA-Z0-9_]*\")) {\n    order=\"id\";\n  }\n  try {\n    ResultSet rs=stat.executeQuery(\"SELECT ID, NAME FROM ITEMS ORDER BY \" + order);\n    while (rs.next()) {\n      System.out.println(rs.getString(1) + \": \" + rs.getString(2));\n    }\n  }\n catch (  SQLException e) {\n    System.out.println(e);\n  }\n}\n", "nl": "List items using a specified sort order. The method is secure as the user input is validated before use. However the database has no chance to verify this."}
{"code": "private int readInt(InputStream is) throws IOException {\n  return ((is.read() << 24) | (is.read() << 16) | (is.read() << 8)| (is.read()));\n}\n", "nl": "Parses a 32-bit int."}
{"code": "void enableConfirmButtons(){\n  confirmChangesButton.setToolTipText(SymbolicProgBundle.getMessage(\"TipConfirmChangesSheet\"));\n  confirmAllButton.setToolTipText(SymbolicProgBundle.getMessage(\"TipConfirmAllSheet\"));\n  if (_cvModel.getProgrammer() != null && !_cvModel.getProgrammer().getCanRead()) {\n    confirmChangesButton.setEnabled(false);\n    confirmAllButton.setEnabled(false);\n    confirmChangesButton.setToolTipText(SymbolicProgBundle.getMessage(\"TipNoRead\"));\n    confirmAllButton.setToolTipText(SymbolicProgBundle.getMessage(\"TipNoRead\"));\n  }\n else {\n    confirmChangesButton.setEnabled(true);\n    confirmAllButton.setEnabled(true);\n  }\n}\n", "nl": "Enable the compare all and compare changes button if possible. This checks to make sure this is appropriate, given the attached programmer's capability."}
{"code": "private String eventName(String taskType,int taskNum,String evtType){\n  assert nodeId != null;\n  return taskType + \" \" + taskNum+ \" \"+ evtType+ \" \"+ nodeId;\n}\n", "nl": "Generate name that consists of some event information."}
{"code": "@Override public NotificationChain eInverseRemove(InternalEObject otherEnd,int featureID,NotificationChain msgs){\nswitch (featureID) {\ncase UmplePackage.ACTION___ANONYMOUS_ACTION_11:\n    return ((InternalEList<?>)getAnonymous_action_1_1()).basicRemove(otherEnd,msgs);\ncase UmplePackage.ACTION___ANONYMOUS_ACTION_21:\n  return ((InternalEList<?>)getAnonymous_action_2_1()).basicRemove(otherEnd,msgs);\n}\nreturn super.eInverseRemove(otherEnd,featureID,msgs);\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public static void showPathInFileBrowser(final Path path){\n  try {\n    final boolean isFolder=Files.isDirectory(path);\n    final boolean isFile=!isFolder;\n    if (isFile && LEnv.OS == OpSys.WINDOWS) {\n      new ProcessBuilder(\"explorer.exe\",\"/select,\",path.toAbsolutePath().toString()).start();\n    }\n else     Desktop.getDesktop().open(isFolder ? path.toFile() : path.getParent().toFile());\n  }\n catch (  final IOException ie) {\n    LEnv.LOGGER.warning(\"Failed to open file browser!\",ie);\n  }\n}\n", "nl": "Opens the specified file or folder in the default file browser application of the user's OS. <p> If a file is specified, on Windows it will also be selected. </p>"}
{"code": "private <T>T processExtremes(Stamp forX,Stamp forY,BiFunction<Long,Long,T> op){\n  IntegerStamp xStamp=(IntegerStamp)forX;\n  IntegerStamp yStamp=(IntegerStamp)forY;\n  JavaKind kind=getStackKind();\n  assert kind == JavaKind.Int || kind == JavaKind.Long;\n  long[] xExtremes=getUnsignedExtremes(xStamp);\n  long[] yExtremes=getUnsignedExtremes(yStamp);\n  long min=Long.MAX_VALUE;\n  long max=Long.MIN_VALUE;\n  for (  long a : xExtremes) {\n    for (    long b : yExtremes) {\n      long result=kind == JavaKind.Int ? multiplyHighUnsigned((int)a,(int)b) : multiplyHighUnsigned(a,b);\n      min=Math.min(min,result);\n      max=Math.max(max,result);\n    }\n  }\n  return op.apply(min,max);\n}\n", "nl": "Determines the minimum and maximum result of this node for the given inputs and returns the result of the given BiFunction on the minimum and maximum values. Note that the minima and maxima are calculated using signed min/max functions, while the values themselves are unsigned."}
{"code": "public String toSignatureString(){\n  StringBuilder sb=new StringBuilder();\n  String accessLevel=convertModifiersToAccessLevel(mModifier);\n  if (!\"\".equals(accessLevel)) {\n    sb.append(accessLevel).append(\" \");\n  }\n  if (!JDiffType.INTERFACE.equals(mClassType)) {\n    String modifierString=convertModifersToModifierString(mModifier);\n    if (!\"\".equals(modifierString)) {\n      sb.append(modifierString).append(\" \");\n    }\n    sb.append(\"class \");\n  }\n else {\n    sb.append(\"interface \");\n  }\n  sb.append(mShortClassName);\n  if (mExtendedClass != null) {\n    sb.append(\" extends \").append(mExtendedClass).append(\" \");\n  }\n  if (implInterfaces.size() > 0) {\n    sb.append(\" implements \");\n    for (int x=0; x < implInterfaces.size(); x++) {\n      String interf=implInterfaces.get(x);\n      sb.append(interf);\n      if (x + 1 != implInterfaces.size()) {\n        sb.append(\", \");\n      }\n    }\n  }\n  return sb.toString();\n}\n", "nl": "Convert the class into a printable signature string."}
{"code": "public void showPopup(){\n  if (getPopup() != null) {\n    getPopup().setVisible(true);\n  }\n}\n", "nl": "if a JPopupMenu is set, it is displayed again. Displaying this dialog closes any JPopupMenu automatically."}
{"code": "public boolean isGame(){\n  return true;\n}\n", "nl": "Determines if this marker is a game. Default is true, so override is only necessary if implementation is not a game."}
{"code": "private FigureLayerComparator(){\n}\n", "nl": "Creates a new instance."}
{"code": "public TDoubleDoubleHashMap normalizedDistribution(){\n  return normalizedDistribution(absoluteDistribution());\n}\n", "nl": "Returns a histogram of all samples where the values are normalized so that the sum of all samples equals one."}
{"code": "private void waitForUsers(URI hostUri,String authToken) throws Throwable {\n  URI usersLink=UriUtils.buildUri(hostUri,UserService.FACTORY_LINK);\n  Integer[] numberUsers=new Integer[1];\n  for (int i=0; i < 20; i++) {\n    Operation get=Operation.createGet(usersLink).forceRemote().addRequestHeader(Operation.REQUEST_AUTH_TOKEN_HEADER,authToken).setCompletion(null);\n    this.host.testStart(1);\n    this.host.send(get);\n    this.host.testWait();\n    if (numberUsers[0] == 2) {\n      break;\n    }\n    Thread.sleep(250);\n  }\n  assertTrue(numberUsers[0] == 2);\n}\n", "nl": "Supports createUsers() by waiting for two users to be created. They aren't created immediately, so this polls."}
{"code": "public synchronized int send(byte[] buffer,int offset,int len) throws IOException {\n  if (m_state != PseudoTcpState.TCP_ESTABLISHED) {\n    throw new IOException(\"Socket not connected\");\n  }\n  long available_space;\n  available_space=m_sbuf.getWriteRemaining();\n  if (available_space == 0) {\n    m_bWriteEnable=true;\n    return 0;\n  }\n  int written=queue(buffer,offset,len,false);\n  attemptSend(SendFlags.sfNone);\n  return written;\n}\n", "nl": "Enqueues data in the send buffer"}
{"code": "public SampleAxioms(){\n  super();\n}\n", "nl": "De-serialization ctor."}
{"code": "public void validateTagTypeKey(TagTypeKey tagTypeKey) throws IllegalArgumentException {\n  Assert.notNull(tagTypeKey,\"A tag type key must be specified.\");\n  tagTypeKey.setTagTypeCode(alternateKeyHelper.validateStringParameter(\"tag type code\",tagTypeKey.getTagTypeCode()));\n}\n", "nl": "Validates a tag type key. This method also trims the key parameters."}
{"code": "public static BigInteger nextPrime(long n){\n  long i;\n  boolean found=false;\n  long result=0;\n  if (n <= 1) {\n    return BigInteger.valueOf(2);\n  }\n  if (n == 2) {\n    return BigInteger.valueOf(3);\n  }\n  for (i=n + 1 + (n & 1); (i <= n << 1) && !found; i+=2) {\n    for (long j=3; (j <= i >> 1) && !found; j+=2) {\n      if (i % j == 0) {\n        found=true;\n      }\n    }\n    if (found) {\n      found=false;\n    }\n else {\n      result=i;\n      found=true;\n    }\n  }\n  return BigInteger.valueOf(result);\n}\n", "nl": "Computes the next prime greater than n."}
{"code": "@Override public void addCharacterToOutput(final Entry<Character,GrayscaleMatrix> characterEntry,final int[] sourceImagePixels,final int tileX,final int tileY,final int imageWidth){\n  this.output.append(characterEntry.getKey());\n  if ((tileX + 1) * this.characterCache.getCharacterImageSize().getWidth() == imageWidth) {\n    this.output.append(System.lineSeparator());\n  }\n}\n", "nl": "Append choosen character to StringBuffer."}
{"code": "@VisibleForTesting static int chooseTableSize(int setSize){\n  if (setSize == 1) {\n    return 2;\n  }\n  int tableSize=Integer.highestOneBit(setSize - 1) << 1;\n  while (tableSize * DESIRED_LOAD_FACTOR < setSize) {\n    tableSize<<=1;\n  }\n  return tableSize;\n}\n", "nl": "Returns an array size suitable for the backing array of a hash table that uses open addressing with linear probing in its implementation. The returned size is the smallest power of two that can hold setSize elements with the desired load factor."}
{"code": "public void validateMinimum(){\n  double newMin;\n  try {\n    newMin=Double.parseDouble(this.minimumRangeValue.getText());\n    if (newMin >= this.maximumValue) {\n      newMin=this.minimumValue;\n    }\n  }\n catch (  NumberFormatException e) {\n    newMin=this.minimumValue;\n  }\n  this.minimumValue=newMin;\n  this.minimumRangeValue.setText(Double.toString(this.minimumValue));\n}\n", "nl": "Revalidate the range minimum."}
{"code": "public static void init(ActorSystem actorSystem){\n  if (instance == null) {\n    instance=actorSystem.actorOf(Props.create(BatchSigner.class));\n  }\n}\n", "nl": "Initializes the batch signer with the given actor system."}
{"code": "private static void dump(PrintData pd){\n  dumpHeader(pd);\n  for (int i=0; i < pd.getRowCount(); i++)   dumpRow(pd,i);\n}\n", "nl": "Dump all PrintData - header and rows"}
{"code": "public boolean isHIGHER(){\n  return value == HIGHER;\n}\n", "nl": "Is the condition code HIGHER?"}
{"code": "public Matrix4x3d rotateZ(double ang){\n  return rotateZ(ang,this);\n}\n", "nl": "Apply rotation about the Z axis to this matrix by rotating the given amount of radians. <p> When used with a right-handed coordinate system, the produced rotation will rotate a vector  counter-clockwise around the rotation axis, when viewing along the negative axis direction towards the origin. When used with a left-handed coordinate system, the rotation is clockwise. <p> If <code>M</code> is <code>this</code> matrix and <code>R</code> the rotation matrix, then the new matrix will be <code>M * R</code>. So when transforming a vector <code>v</code> with the new matrix by using <code>M * R * v</code>, the rotation will be applied first! <p> Reference: <a href=\"http://en.wikipedia.org/wiki/Rotation_matrix#Basic_rotations\">http://en.wikipedia.org</a>"}
{"code": "@Override protected URLConnection openConnection(URL url,Proxy proxy) throws IOException {\n  if (url == null || proxy == null) {\n    throw new IllegalArgumentException(\"url == null || proxy == null\");\n  }\n  return new FtpURLConnection(url,proxy);\n}\n", "nl": "Returns a connection, which is established via the <code>proxy</code>, to the FTP server specified by this <code>URL</code>. If <code>proxy</code> is DIRECT type, the connection is made in normal way."}
{"code": "private boolean matchesMobile4g(NetworkIdentity ident){\n  ensureSubtypeAvailable();\n  if (ident.mType == TYPE_WIMAX) {\n    return true;\n  }\n else   if (matchesMobile(ident)) {\nswitch (getNetworkClass(ident.mSubType)) {\ncase NETWORK_CLASS_4_G:\n      return true;\n  }\n}\nreturn false;\n}\n", "nl": "Check if mobile network classified 4G with matching IMSI."}
{"code": "public void writeToBuffer(ByteBuf buffer) throws Exception {\n  if (id != -1) {\n    Type.VAR_INT.write(buffer,id);\n  }\n  if (readableObjects.size() > 0) {\n    packetValues.addAll(readableObjects);\n    readableObjects.clear();\n  }\n  int index=0;\n  for (  Pair<Type,Object> packetValue : packetValues) {\n    try {\n      Object value=packetValue.getValue();\n      if (value != null) {\n        if (!packetValue.getKey().getOutputClass().isAssignableFrom(value.getClass())) {\n          if (packetValue.getKey() instanceof TypeConverter) {\n            value=((TypeConverter)packetValue.getKey()).from(value);\n          }\n else {\n            System.out.println(\"Possible type mismatch: \" + value.getClass().getName() + \" -> \"+ packetValue.getKey().getOutputClass());\n          }\n        }\n      }\n      packetValue.getKey().write(buffer,value);\n    }\n catch (    Exception e) {\n      throw new InformativeException(e).set(\"Index\",index).set(\"Type\",packetValue.getKey().getTypeName()).set(\"Packet ID\",getId()).set(\"Data\",packetValues);\n    }\n    index++;\n  }\n  writeRemaining(buffer);\n}\n", "nl": "Write the current output to a buffer."}
{"code": "public RandomDecisionTree(int numFeatures,int maxDepth,int minSamples,TreePruner.PruningMethod pruningMethod,double testProportion){\n  super(maxDepth,minSamples,pruningMethod,testProportion);\n  setRandomFeatureCount(numFeatures);\n}\n", "nl": "Creates a new Random Decision Tree"}
{"code": "protected void fireCommentEvent(char[] chars,int start,int length) throws org.xml.sax.SAXException {\n  if (m_tracer != null) {\n    flushMyWriter();\n    m_tracer.fireGenerateEvent(SerializerTrace.EVENTTYPE_COMMENT,new String(chars,start,length));\n  }\n}\n", "nl": "Report the comment trace event"}
{"code": "private void init(Context context,AttributeSet attrs,RuqusTheme theme){\n  inflate(context,R.layout.rqv_card,this);\n  outlineView=(FrameLayout)findViewById(R.id.outline);\n  outlineTextView=(TextView)findViewById(R.id.outline_text);\n  cardView=(CardView)findViewById(R.id.card);\n  cardTextView=(TextView)findViewById(R.id.card_text);\n  setTheme(theme);\n  TypedArray typedArray=context.obtainStyledAttributes(attrs,R.styleable.RQVCard);\n  mode=typedArray.getInt(R.styleable.RQVCard_rqv_card_mode,0) == 0 ? Mode.OUTLINE : Mode.CARD;\n  outlineTextView.setText(typedArray.getString(R.styleable.RQVCard_rqv_outline_text));\n  cardTextView.setText(typedArray.getString(R.styleable.RQVCard_rqv_card_text));\n  typedArray.recycle();\n}\n", "nl": "Initialize our view."}
{"code": "public void onUndeploy(ClassLoader ldr){\n  for (  Class<?> cls : descByCls.keySet()) {\n    if (ldr.equals(cls.getClassLoader()))     descByCls.remove(cls);\n  }\n  U.clearClassCache(ldr);\n}\n", "nl": "Undeployment callback invoked when class loader is being undeployed. Some marshallers may want to clean their internal state that uses the undeployed class loader somehow."}
{"code": "@Override public int compare(final Long o1,final Long o2){\n  if (o1.longValue() < o2.longValue())   return 1;\n  if (o1.longValue() > o2.longValue())   return -1;\n  return 0;\n}\n", "nl": "Comparator puts the entries into descending order by the query execution time (longest running queries are first)."}
{"code": "public void testResourceParameterOfListType(){\n  doTest();\n}\n", "nl": "Tests that a ResourceParameterInspection error is generated for a resource parameter of List type."}
{"code": "public TeXFormula add(String s) throws ParseException {\n  if (s != null && s.length() != 0) {\n    textStyle=null;\n    add(new TeXFormula(s));\n  }\n  return this;\n}\n", "nl": "Parses the given string and inserts the resulting formula at the end of the current TeXFormula."}
{"code": "public ResponseEntity<List<Recommendation>> defaultRecommendations(int productId){\n  LOG.warn(\"Using fallback method for recommendation-service\");\n  return util.createResponse(Arrays.asList(new Recommendation(productId,1,\"Fallback Author 1\",1,\"Fallback Content 1\")),HttpStatus.OK);\n}\n", "nl": "Fallback method for getRecommendations()"}
{"code": "private void cmd_annotateDifference(){\n  BigDecimal previousValue, actualValue, difference;\n  previousValue=(BigDecimal)v_previousBalance.getValue();\n  actualValue=(BigDecimal)v_ActualBalance.getValue();\n  difference=actualValue.subtract(previousValue);\n  MCashBook cashBook=new MCashBook(p_ctx,p_pos.getC_CashBook_ID(),null);\n  Timestamp today=TimeUtil.getDay(System.currentTimeMillis());\n  MCash cash=MCash.get(p_ctx,cashBook.getC_CashBook_ID(),today,null);\n  if (cash != null && cash.get_ID() != 0 && difference.compareTo(cash.getStatementDifference()) != 0) {\n    MCashLine cl=new MCashLine(cash);\n    cl.setCashType(MCashLine.CASHTYPE_Difference);\n    cl.setAmount(difference);\n    cl.setDescription(Msg.translate(p_pos.getCtx(),\"Cash Scrutiny -> Before: \") + previousValue + \" Now: \"+ actualValue);\n    cl.saveEx();\n  }\n  cash=MCash.get(p_pos.getCtx(),p_pos.getC_CashBook_ID(),today,null);\n  v_previousBalance.setValue(cash.getEndingBalance());\n  v_ActualBalance.setValue(Env.ZERO);\n  v_difference.setValue(Env.ZERO);\n}\n", "nl": "Annotate the difference between previous balance and actual from cash scrutiny in the cash book"}
{"code": "public boolean hasJpgThumbnail(){\n  if (getThumbnailType() != ExifDirectory.COMPRESSION_JPEG)   return false;\n  byte[] thumbData;\n  try {\n    ExifDirectory exif=(ExifDirectory)metadata.getDirectory(ExifDirectory.class);\n    thumbData=exif.getThumbnailData();\n  }\n catch (  MetadataException e) {\n    return false;\n  }\n  if (thumbData.length > 2) {\n    int magicNumber;\n    magicNumber=(thumbData[0] & 0xFF) << 8;\n    magicNumber|=(thumbData[1] & 0xFF);\n    if (magicNumber == ImageMetadataReader.JPEG_FILE_MAGIC_NUMBER)     return true;\n  }\n  return false;\n}\n", "nl": "Performs checks to determine if the image has a JPG thumbnail in the EXIF data. <p> The EXIF TAG_COMPRESION , and the magic number at the beginning of the thumbnail bytes are used to verify that the thumb is in JPG format"}
{"code": "private void waitForRScriptInitialized() throws InterpreterException {\nsynchronized (rScriptInitializeNotifier) {\n    long startTime=System.nanoTime();\n    while (rScriptInitialized == false && rScriptRunning && System.nanoTime() - startTime < 10L * 1000 * 1000000) {\n      try {\n        rScriptInitializeNotifier.wait(1000);\n      }\n catch (      InterruptedException e) {\n        logger.error(e.getMessage(),e);\n      }\n    }\n  }\n  String errorMessage=\"\";\n  try {\n    initialOutput.flush();\n    errorMessage=new String(initialOutput.toByteArray());\n  }\n catch (  IOException e) {\n    e.printStackTrace();\n  }\n  if (rScriptInitialized == false) {\n    throw new InterpreterException(\"sparkr is not responding \" + errorMessage);\n  }\n}\n", "nl": "Wait until src/main/resources/R/zeppelin_sparkr.R is initialized and call onScriptInitialized()"}
{"code": "private DefaultUnitConverter(){\n}\n", "nl": "Constructs a DefaultUnitConverter and registers a listener that handles changes in the look&amp;feel."}
{"code": "public static String morpha(String text,boolean tags){\n  if (text.isEmpty()) {\n    return \"\";\n  }\n  String[] textParts=whitespace.split(text);\n  StringBuilder result=new StringBuilder();\n  try {\n    for (    String textPart : textParts) {\n      Morpha morpha=new Morpha(new StringReader(textPart),tags);\n      if (result.length() != 0) {\n        result.append(\" \");\n      }\n      result.append(morpha.next());\n    }\n  }\n catch (  Error e) {\n    return text;\n  }\ncatch (  java.io.IOException e) {\n    return text;\n  }\n  return result.toString();\n}\n", "nl": "Run the morpha algorithm on the specified string."}
{"code": "protected void readUnzipedResponse(InputStream input) throws IOException {\n  super.readResponse(input);\n}\n", "nl": "This method can be overridden instead of readResponse"}
{"code": "public EventStream<S> events() throws Exception {\n  return EventStream.empty();\n}\n", "nl": "Returns a stream of events that should be recorded. By default, an empty stream returned."}
{"code": "public String lookupCacheSizeTipText(){\n  return \"Set the maximum size of the lookup cache of evaluated subsets. This is \" + \"expressed as a multiplier of the number of attributes in the data set. \" + \"(default = 1).\";\n}\n", "nl": "Returns the tip text for this property"}
{"code": "private SimpleObject providerToJson(Provider provider){\n  SimpleObject jsonForm=new SimpleObject();\n  if (provider != null) {\n    jsonForm.add(USER_ID,provider.getUuid());\n    jsonForm.add(FULL_NAME,provider.getName());\n    Person person=provider.getPerson();\n    if (person != null) {\n      jsonForm.add(GIVEN_NAME,person.getGivenName());\n      jsonForm.add(FAMILY_NAME,person.getFamilyName());\n    }\n  }\n  return jsonForm;\n}\n", "nl": "Builds a SimpleObject describing the given Provider."}
{"code": "@Override public int next() throws XMLStreamException {\n  log.fine(\"next()\");\n  if (event == START_DOCUMENT) {\n    event=START_ELEMENT;\n    elementIndex.currentElement=parser.getDocument().getBody().getElement();\n  }\n else   if (event == START_ELEMENT) {\n    elementIndex.index=0;\n    event=nextInElement(false);\n  }\n else   if (event == ATTRIBUTE) {\n    elementIndex.index=0;\n    event=nextInElement(false);\n  }\n else   if (event == CHARACTERS) {\n    elementIndex.index++;\n    event=nextInElement(false);\n  }\n else   if (event == SPACE) {\n    elementIndex.index++;\n    event=nextInElement(false);\n  }\n else   if (event == ENTITY_REFERENCE) {\n    elementIndex.index++;\n    event=nextInElement(false);\n  }\n else   if (event == PROCESSING_INSTRUCTION) {\n    elementIndex.index++;\n    event=nextInElement(false);\n  }\n else   if (event == END_ELEMENT) {\n    if (parents.isEmpty()) {\n      event=END_DOCUMENT;\n    }\n else {\n      elementIndex=parents.pop();\n      elementIndex.index++;\n      event=nextInElement(false);\n    }\n  }\n else   if (event == END_DOCUMENT) {\n    throw new XMLStreamException(\"End of coument reached!\");\n  }\n else {\n    throw new XMLStreamException(\"Invalid event state!\");\n  }\n  log.log(Level.FINE,\"next(): {0}\",event);\n  return event;\n}\n", "nl": "Get next parsing event - a processor may return all contiguous character  data in a single chunk, or it may split it into several chunks. If the  property javax.xml.stream.isCoalescing is set to true element content  must be coalesced and only one CHARACTERS event must be returned for  contiguous element content or CDATA Sections. By default entity  references must be expanded and reported transparently to the application.  An exception will be thrown if an entity reference cannot be expanded.  If element content is empty (i.e. content is \"\") then no CHARACTERS  event will be reported. <p>This method marks the current element and index using the elementIndex structure. Besides a queue of parents element index is maintained to cross over all element hierarchy.</p> <p>The WbXMLStreamReader only manages the following states:</p> <ul> <li>START_DOCUMENT</li> <li>PROCESSING_INSTRUCTION</li> <li>START_ELEMENT</li> <li>ATTRIBUTE</li> <lI>CHARACTERS</li> <li>END_ELEMENT</li> <li>SPACE</li> <li>END_DOCUMENT</li> <li>ENTITY_REFERENCE</li> </ul> <p>Therefore the following element does no matter in this stream reader:</p> <ul> <li>CDATA (CHARACTERS are used always).</li> <li>COMMENT (no comments in WBXML).</li> <li>DTD (no DTD section)</li> <li>ENTITY_DECLARATION</li> <li>NAMESPACE</li> <li>NOTATION DECLARATION</li> </ul>"}
{"code": "@SuppressWarnings(\"unchecked\") public synchronized List<Relationship> findAllRelationshipsTo(Vertex vertex){\n  Query query=this.entityManager.createQuery(\"Select r from Relationship r where r.target = :vertex or r.type = :vertex\");\n  setHints(query);\n  query.setParameter(\"vertex\",vertex);\n  return query.getResultList();\n}\n", "nl": "Find all relationships related to the vertex or of the vertex relationship type."}
{"code": "public static String convertMethodSignature(InvokeInstruction inv,ConstantPoolGen cpg){\n  return convertMethodSignature(inv.getClassName(cpg),inv.getName(cpg),inv.getSignature(cpg));\n}\n", "nl": "Convenience method for generating a method signature in human readable form."}
{"code": "@Override public int count(Selector obj){\n  if ((obj.getMask() & Selector.MASK_INSTANCE) > 0) {\n    if (device.findObject(obj.toUiSelector()).exists())     return 1;\n else     return 0;\n  }\n else {\n    UiSelector sel=obj.toUiSelector();\n    if (!device.findObject(sel).exists())     return 0;\n    int low=1;\n    int high=2;\n    sel=sel.instance(high - 1);\n    while (device.findObject(sel).exists()) {\n      low=high;\n      high=high * 2;\n      sel=sel.instance(high - 1);\n    }\n    while (high > low + 1) {\n      int mid=(low + high) / 2;\n      sel=sel.instance(mid - 1);\n      if (device.findObject(sel).exists())       low=mid;\n else       high=mid;\n    }\n    return low;\n  }\n}\n", "nl": "Get the count of the UiObject instances by the selector"}
{"code": "private boolean isComputeHost(ComputeDescription computeDescription){\n  List<String> supportedChildren=computeDescription.supportedChildren;\n  return supportedChildren != null && supportedChildren.contains(ComputeType.VM_GUEST.name());\n}\n", "nl": "Returns if the given compute description is a compute host or not."}
{"code": "public File prepareTestDir(String logDirName) throws Exception {\n  File logDir=new File(logDirName);\n  FilePath path=new FilePath(logDir.getAbsolutePath());\n  fileIO.delete(path,true);\n  fileIO.mkdir(path);\n  return logDir;\n}\n", "nl": "Create an empty test directory or if the directory exists remove any files within it."}
{"code": "public void receiveErrorqueryAssociatedPortsForProcessor(java.lang.Exception e){\n}\n", "nl": "auto generated Axis2 Error handler override this method for handling error response from queryAssociatedPortsForProcessor operation"}
{"code": "@Override public Object clone() throws CloneNotSupportedException {\n  return super.clone();\n}\n", "nl": "Returns a clone of this instance."}
{"code": "private void dump(File from,OutputStream out) throws IOException {\n  writeHeader(from,out);\n  FileInputStream in=null;\n  try {\n    in=new FileInputStream(from);\n    int count;\n    while ((count=in.read(buffer)) != -1) {\n      out.write(buffer,0,count);\n    }\n  }\n  finally {\n    closeQuietly(in);\n  }\n}\n", "nl": "Copies from a file to an output stream."}
{"code": "public static long lastLocalId(){\n  return cntGen.get();\n}\n", "nl": "Gets last generated local ID."}
{"code": "RoleEventImpl(Region region,Operation op,Object callbackArgument,boolean originRemote,DistributedMember distributedMember,Set requiredRoles){\n  super(region,op,callbackArgument,originRemote,distributedMember);\n  this.requiredRoles=Collections.unmodifiableSet(requiredRoles);\n}\n", "nl": "Constructs new RoleEventImpl."}
{"code": "public QLFFilesCollection(File directory,String extension,Class<F> featureClass,String pathRegexFind,String pathRegexRep){\n  this(featureClass,pathRegexFind,pathRegexRep);\n  processDirs(directory,extension);\n}\n", "nl": "Construct the collection from the files in the given directory that have the given file extension. All the files are expected to contain features of the given feature class. The file search is recursive, and will also look in sub-directories of the specified directory. The final two parameters allow a regular-expression find and replace operation for be performed on the found filenames in order to create the document identifier for each QLFDocument. This is useful to ensure only the document name is stored in the index, rather than the absolute path."}
{"code": "public static void main(String[] args) throws IOException {\n  boolean enableOutput=true;\n  boolean outputToFile=false;\n  String inputFolder=LrMc.class.getClassLoader().getResource(\"workload/planetlab\").getPath();\n  String outputFolder=\"output\";\n  String workload=\"20110303\";\n  String vmAllocationPolicy=\"lr\";\n  String vmSelectionPolicy=\"mc\";\n  String parameter=\"1.2\";\n  new PlanetLabRunner(enableOutput,outputToFile,inputFolder,outputFolder,workload,vmAllocationPolicy,vmSelectionPolicy,parameter);\n}\n", "nl": "The main method."}
{"code": "void make(BulkTest bulk){\n  Class c=bulk.getClass();\n  Method[] all=c.getMethods();\n  for (int i=0; i < all.length; i++) {\n    if (isTest(all[i]))     addTest(bulk,all[i]);\n    if (isBulk(all[i]))     addBulk(bulk,all[i]);\n  }\n}\n", "nl": "Appends all the simple tests and bulk tests defined by the given instance's class to the current TestSuite."}
{"code": "private void readObject(java.io.ObjectInputStream in) throws IOException, ClassNotFoundException {\n  String inName=(String)in.readObject();\n  String inDescription=(String)in.readObject();\n  Object inValue=in.readObject();\n  Class inClass=(Class)in.readObject();\n  boolean inUserModifiable=in.readBoolean();\n  Assert.assertTrue(inName != null);\n  Assert.assertTrue(inDescription != null);\n  Assert.assertTrue(inValue != null);\n  Assert.assertTrue(inClass != null);\n  this.deserialized=true;\n  this.name=inName;\n  setInternalState(inDescription,inValue,inClass,inUserModifiable);\n}\n", "nl": "Override readObject which is used in serialization. Customize serialization of this exception to avoid escape of InternalRole which is not Serializable."}
{"code": "private void returnData(Object ret){\n  if (myHost != null) {\n    myHost.returnData(ret);\n  }\n}\n", "nl": "Used to communicate a return object from a plugin tool to the main Whitebox user-interface."}
{"code": "public static String escape(String s){\n  if (s == null)   return null;\n  StringBuffer sb=new StringBuffer();\n  escape(s,sb);\n  return sb.toString();\n}\n", "nl": "Escape quotes, \\, /, \\r, \\n, \\b, \\f, \\t and other control characters (U+0000 through U+001F)."}
{"code": "public ArrayDeque<E> clone(){\n  try {\n    @SuppressWarnings(\"unchecked\") ArrayDeque<E> result=(ArrayDeque<E>)super.clone();\n    result.elements=Arrays.copyOf(elements,elements.length);\n    return result;\n  }\n catch (  CloneNotSupportedException e) {\n    throw new AssertionError();\n  }\n}\n", "nl": "Returns a copy of this deque."}
{"code": "public void generateCode(BlockScope currentScope){\n  if ((this.bits & IsReachable) == 0) {\n    return;\n  }\n  generateInit: {\n    if (this.initialization == null)     break generateInit;\n    if (this.binding.resolvedPosition < 0) {\n      if (this.initialization.constant != Constant.NotAConstant)       break generateInit;\n      this.initialization.generateCode(currentScope,false);\n      break generateInit;\n    }\n    this.initialization.generateCode(currentScope,true);\n  }\n}\n", "nl": "Code generation for a local declaration: i.e.&nbsp;normal assignment to a local variable + unused variable handling"}
{"code": "public static boolean isPotentialValidLink(File file) throws IOException {\n  boolean isPotentiallyValid;\n  try (InputStream fis=new FileInputStream(file)){\n    final int minimumLength=0x64;\n    isPotentiallyValid=file.isFile() && file.getName().toLowerCase().endsWith(\".lnk\") && fis.available() >= minimumLength && isMagicPresent(getBytes(fis,32));\n  }\n   return isPotentiallyValid;\n}\n", "nl": "Provides a quick test to see if this could be a valid link ! If you try to instantiate a new WindowShortcut and the link is not valid, Exceptions may be thrown and Exceptions are extremely slow to generate, therefore any code needing to loop through several files should first check this."}
{"code": "public IGameMove decideMove(IGameState state){\n  if (state.isDraw())   return null;\n  if (state.isWin())   return null;\n  Collection<IGameMove> moves=logic.validMoves(this,state);\n  if (moves.size() == 0) {\n    return null;\n  }\n else {\n    IGameMove[] mvs=moves.toArray(new IGameMove[]{});\n    int idx=(int)(Math.random() * moves.size());\n    return mvs[idx];\n  }\n}\n", "nl": "Randomly make a move based upon the available logic of the game. Make sure you check that the game is not already won, lost or drawn before calling  this method, because you "}
{"code": "public static int nextPowerOf2(int x){\n  long i=1;\n  while (i < x && i < (Integer.MAX_VALUE / 2)) {\n    i+=i;\n  }\n  return (int)i;\n}\n", "nl": "Get the value that is equal or higher than this value, and that is a power of two."}
{"code": "public Point2D inverseTransform(Point2D viewPoint){\n  Point2D viewCenter=getViewCenter();\n  double viewRadius=getViewRadius();\n  double ratio=getRatio();\n  double dx=viewPoint.getX() - viewCenter.getX();\n  double dy=viewPoint.getY() - viewCenter.getY();\n  dx*=ratio;\n  Point2D pointFromCenter=new Point2D.Double(dx,dy);\n  PolarPoint polar=PolarPoint.cartesianToPolar(pointFromCenter);\n  double radius=polar.getRadius();\n  if (radius > viewRadius)   return delegate.inverseTransform(viewPoint);\n  radius/=viewRadius;\n  radius=Math.abs(Math.tan(radius));\n  radius/=Math.PI / 2;\n  radius*=viewRadius;\n  double mag=Math.tan(Math.PI / 2 * magnification);\n  radius/=mag;\n  polar.setRadius(radius);\n  Point2D projectedPoint=PolarPoint.polarToCartesian(polar);\n  projectedPoint.setLocation(projectedPoint.getX() / ratio,projectedPoint.getY());\n  Point2D translatedBack=new Point2D.Double(projectedPoint.getX() + viewCenter.getX(),projectedPoint.getY() + viewCenter.getY());\n  return delegate.inverseTransform(translatedBack);\n}\n", "nl": "override base class to un-project the fisheye effect"}
{"code": "private boolean iconBoundsIntersectBar(RectF barBounds,Rect icon,double scaleFactor){\n  int iconL=icon.left + scale(icon.width(),scaleFactor);\n  int iconT=icon.top + scale(icon.height(),scaleFactor);\n  int iconR=icon.right - scale(icon.width(),scaleFactor);\n  int iconB=icon.bottom - scale(icon.height(),scaleFactor);\n  return barBounds.intersects(iconL,iconT,iconR,iconB);\n}\n", "nl": "Helper method for calculating intersections for control icons and bars."}
{"code": "public void closeRegistration(){\n  flushDeferrables();\n  for (  Map.Entry<String,ClassPlugins> e : registrations.entrySet()) {\n    e.getValue().initializeMap();\n  }\n}\n", "nl": "Disallows new registrations of new plugins, and creates the internal tables for method lookup."}
{"code": "public static String toGml(final IDirectedGraph<?,? extends IGraphEdge<?>> graph){\n  Preconditions.checkNotNull(graph,\"Graph argument can not be null\");\n  final StringBuilder sb=new StringBuilder();\n  sb.append(\"graph\\n\" + \"[\\n\");\n  int currentId=0;\n  final Map<Object,Integer> nodeMap=new HashMap<>();\n  for (  final Object node : graph.getNodes()) {\n    sb.append(\"\\tnode\\n\" + \"\\t[\\n\" + \"\\tid \"+ \"\\n\");\n    sb.append(currentId);\n    sb.append(\"\\tlabel \\\"\");\n    sb.append(node);\n    sb.append(\"\\\"\\n\" + \"\\t]\\n\");\n    nodeMap.put(node,currentId);\n    ++currentId;\n  }\n  for (  final IGraphEdge<?> edge : graph.getEdges()) {\n    sb.append(\"\\tedge\\n\" + \"\\t[\\n\" + \"\\tsource \");\n    sb.append(nodeMap.get(edge.getSource()));\n    sb.append(\"\\n\" + \"\\ttarget \");\n    sb.append(nodeMap.get(edge.getTarget()));\n    sb.append(\"\\n\" + \"\\tgraphics\\n\" + \"\\t[\\n\"+ \"\\t\\tfill \\\"#000000\\\"\\n\"+ \"\\t\\ttargetArrow \\\"standard\\\"\\n\"+ \"\\t]\\n\"+ \"\\t]\\n\");\n  }\n  sb.append(\"]\\n\");\n  return sb.toString();\n}\n", "nl": "Creates GML code that represents a given directed graph."}
{"code": "void cachePage(long pos,Page page,int memory){\n  if (cache != null) {\n    cache.put(pos,page,memory);\n  }\n}\n", "nl": "Put the page in the cache."}
{"code": "public static Class<?> typeToClass(int type){\n  Class<?> result;\nswitch (type) {\ncase Types.BIGINT:\n    result=Long.class;\n  break;\ncase Types.BINARY:\nresult=String.class;\nbreak;\ncase Types.BIT:\nresult=Boolean.class;\nbreak;\ncase Types.CHAR:\nresult=Character.class;\nbreak;\ncase Types.DATE:\nresult=java.sql.Date.class;\nbreak;\ncase Types.DECIMAL:\nresult=Double.class;\nbreak;\ncase Types.DOUBLE:\nresult=Double.class;\nbreak;\ncase Types.FLOAT:\nresult=Float.class;\nbreak;\ncase Types.INTEGER:\nresult=Integer.class;\nbreak;\ncase Types.LONGVARBINARY:\nresult=String.class;\nbreak;\ncase Types.LONGVARCHAR:\nresult=String.class;\nbreak;\ncase Types.NULL:\nresult=String.class;\nbreak;\ncase Types.NUMERIC:\nresult=Double.class;\nbreak;\ncase Types.OTHER:\nresult=String.class;\nbreak;\ncase Types.REAL:\nresult=Double.class;\nbreak;\ncase Types.SMALLINT:\nresult=Short.class;\nbreak;\ncase Types.TIME:\nresult=java.sql.Time.class;\nbreak;\ncase Types.TIMESTAMP:\nresult=java.sql.Timestamp.class;\nbreak;\ncase Types.TINYINT:\nresult=Short.class;\nbreak;\ncase Types.VARBINARY:\nresult=String.class;\nbreak;\ncase Types.VARCHAR:\nresult=String.class;\nbreak;\ndefault :\nresult=null;\n}\nreturn result;\n}\n", "nl": "Returns the class associated with a SQL type."}
{"code": "private String noteToString(Repository repo,Note note) throws MissingObjectException, IOException, UnsupportedEncodingException {\n  ObjectLoader loader=repo.open(note.getData());\n  ByteArrayOutputStream baos=new ByteArrayOutputStream();\n  loader.copyTo(baos);\n  return new String(baos.toByteArray(),\"UTF-8\");\n}\n", "nl": "Utility method that converts a note to a string (assuming it's UTF-8)."}
{"code": "@TransactionAttribute(TransactionAttributeType.REQUIRES_NEW) public void initTimers() throws ValidationException {\n  initAllTimers();\n}\n", "nl": "Reads the configuration settings for the timer intervals to be used and creates the timers accordingly."}
{"code": "public static String tbiIndexToUniqueString(InputStream is) throws IOException {\n  final StringBuilder ret=new StringBuilder();\n  final byte[] buf=new byte[4096];\n  readIOFully(is,buf,4);\n  final String header=new String(buf,0,4);\n  ret.append(\"Header correct: \").append(header.equals(\"TBI\\u0001\")).append(StringUtils.LS);\n  readIOFully(is,buf,4);\n  final int numRefs=ByteArrayIOUtils.bytesToIntLittleEndian(buf,0);\n  ret.append(\"numRefs: \").append(numRefs).append(StringUtils.LS);\n  readIOFully(is,buf,28);\n  final int format=ByteArrayIOUtils.bytesToIntLittleEndian(buf,0);\n  final int colSeq=ByteArrayIOUtils.bytesToIntLittleEndian(buf,4);\n  final int colBeg=ByteArrayIOUtils.bytesToIntLittleEndian(buf,8);\n  final int colEnd=ByteArrayIOUtils.bytesToIntLittleEndian(buf,12);\n  final int meta=ByteArrayIOUtils.bytesToIntLittleEndian(buf,16);\n  final int skip=ByteArrayIOUtils.bytesToIntLittleEndian(buf,20);\n  final int refNameLength=ByteArrayIOUtils.bytesToIntLittleEndian(buf,24);\n  final String formatStr;\n  formatStr=TbiFormat.values()[format & 0xffff].name();\n  ret.append(\"Format: \").append(formatStr).append(\" 0-based: \").append((format & 0x10000) != 0).append(StringUtils.LS);\n  ret.append(\"Columns: (refName:Start-End) \").append(colSeq).append(\":\").append(colBeg).append(\"-\").append(colEnd).append(StringUtils.LS);\n  ret.append(\"Meta: \").append((char)meta).append(StringUtils.LS);\n  ret.append(\"Skip: \").append(skip).append(StringUtils.LS);\n  final byte[] names=new byte[refNameLength];\n  readIOFully(is,names,names.length);\n  ret.append(\"Sequence names: \");\n  boolean first=true;\n  int off=0;\n  for (int i=0; i < numRefs; i++) {\n    int newOff=off;\n    while (newOff < names.length && names[newOff] != 0) {\n      newOff++;\n    }\n    if (!first) {\n      ret.append(\", \");\n    }\n    ret.append(new String(names,off,newOff - off));\n    off=newOff + 1;\n    first=false;\n  }\n  ret.append(StringUtils.LS);\n  ret.append(indicesToUniqueString(is,numRefs)).append(StringUtils.LS);\n  return ret.toString();\n}\n", "nl": "Creates a string representation of the TABIX index"}
{"code": "public void addFeatureChangeListener(final FeatureChangeListener l){\n  featureListeners.add(l);\n}\n", "nl": "Add a feature change listener."}
{"code": "protected UserPassword(){\n  super();\n}\n", "nl": "Dear JPA..."}
{"code": "public void firePropertyChange(String propertyName,float oldValue,float newValue){\n}\n", "nl": "Overridden for performance reasons. See the <a href=\"#override\">Implementation Note</a> for more information."}
{"code": "public void testUpdate5(){\n  int factor=3;\n  String updateQuery=\"UPDATE \" + DatabaseCreator.TEST_TABLE1 + \" SET field2=field2 *\"+ factor;\n  try {\n    String selectQuery=\"SELECT field2 FROM \" + DatabaseCreator.TEST_TABLE1;\n    ResultSet result=statement.executeQuery(selectQuery);\n    HashSet<BigDecimal> values=new HashSet<BigDecimal>();\n    int num=statement.executeUpdate(updateQuery);\n    assertEquals(\"Not all records in the database were updated\",numberOfRecords,num);\n    result=statement.executeQuery(selectQuery);\n    assertTrue(\"Not all records were updated\",values.isEmpty());\n    result.close();\n  }\n catch (  SQLException e) {\n    fail(\"Unexpected exception\" + e.getMessage());\n  }\n}\n", "nl": "UpdateFunctionalityTest#testUpdate5(). Updates values in one columns in the table using condition"}
{"code": "public final boolean isCaretBlinkEnabled(){\n  return caretBlinks;\n}\n", "nl": "Returns true if the caret is blinking, false otherwise."}
{"code": "public void testBug73663() throws Exception {\n  this.rs=this.stmt.executeQuery(\"show variables like 'collation_server'\");\n  this.rs.next();\n  String collation=this.rs.getString(2);\n  if (collation != null && collation.startsWith(\"utf8mb4\") && \"utf8mb4\".equals(((MySQLConnection)this.conn).getServerVariable(\"character_set_server\"))) {\n    Properties p=new Properties();\n    p.setProperty(\"characterEncoding\",\"UTF-8\");\n    p.setProperty(\"statementInterceptors\",Bug73663StatementInterceptor.class.getName());\n    getConnectionWithProps(p);\n  }\n else {\n    System.out.println(\"testBug73663 was skipped: This test is only run when character_set_server=utf8mb4 and collation-server set to one of utf8mb4 collations.\");\n  }\n}\n", "nl": "Tests fix for Bug#73663 (19479242), utf8mb4 does not work for connector/j >=5.1.13 This test is only run when character_set_server=utf8mb4 and collation-server set to one of utf8mb4 collations (it's better to test two configurations: with default utf8mb4_general_ci and one of non-default, say utf8mb4_bin)"}
{"code": "@Override public void removeEdge(final InstructionGraphEdge edge){\n  super.removeEdge(edge);\n}\n", "nl": "Removes an instruction edge from the instruction graph."}
{"code": "public void addApps(List<AppInfo> apps){\n  mApps.addApps(apps);\n}\n", "nl": "Adds new apps to the list."}
{"code": "public void stop(){\n  final String methodName=\"stop\";\nsynchronized (lifecycle) {\n    log.fine(CLASS_NAME,methodName,\"850\");\n    if (running) {\n      running=false;\n      receiving=false;\n      if (!Thread.currentThread().equals(recThread)) {\n        try {\n          recThread.join();\n        }\n catch (        InterruptedException ex) {\n        }\n      }\n    }\n  }\n  recThread=null;\n  log.fine(CLASS_NAME,methodName,\"851\");\n}\n", "nl": "Stops the Receiver's thread.  This call will block."}
{"code": "First(){\n}\n", "nl": "CONSTRUCTOR <init>"}
{"code": "@Override public String toString(){\n  String temp=\"\";\n  for (int i=0; i < variables.length; i++) {\n    temp+=variables[i].toString();\n    temp+=\"\\n\";\n  }\n  return structName + \"\\n\" + temp;\n}\n", "nl": "Override ToString()."}
{"code": "public void addActionListener(ActionListener l){\n  dispatcher.addListener(l);\n}\n", "nl": "Adds a listener to the switch which will cause an event to dispatch on click"}
{"code": "@Override protected SystemMemberCache createSystemMemberCache(GemFireVM vm) throws org.apache.geode.admin.AdminException {\n  if (managedSystemMemberCache == null) {\n    managedSystemMemberCache=new SystemMemberCacheJmxImpl(vm);\n  }\n  return managedSystemMemberCache;\n}\n", "nl": "Override createSystemMemberCache by instantiating SystemMemberCacheJmxImpl if it was not created earlier."}
{"code": "@Override public void run(){\n  amIActive=true;\n  String inputFile=args[0];\n  if (inputFile.toLowerCase().contains(\".dep\")) {\n    calculateRaster();\n  }\n else   if (inputFile.toLowerCase().contains(\".shp\")) {\n    calculateVector();\n  }\n else {\n    showFeedback(\"There was a problem reading the input file.\");\n  }\n}\n", "nl": "Used to execute this plugin tool."}
{"code": "public void test_compressed_timestamp_01b() throws Exception {\n  new TestHelper(\"compressed-timestamp-01b\",\"compressed-timestamp-01b.rq\",\"compressed-timestamp.ttl\",\"compressed-timestamp-01.srx\").runTest();\n}\n", "nl": "Simple SELECT query returning data typed with the given timestamp, where we have several FILTERs that should evaluate to true."}
{"code": "private void writeAttribute(java.lang.String namespace,java.lang.String attName,java.lang.String attValue,javax.xml.stream.XMLStreamWriter xmlWriter) throws javax.xml.stream.XMLStreamException {\n  if (namespace.equals(\"\")) {\n    xmlWriter.writeAttribute(attName,attValue);\n  }\n else {\n    registerPrefix(xmlWriter,namespace);\n    xmlWriter.writeAttribute(namespace,attName,attValue);\n  }\n}\n", "nl": "Util method to write an attribute without the ns prefix"}
{"code": "private void addTag(String newTag){\n  if (StringUtils.isBlank(newTag)) {\n    return;\n  }\nsynchronized (tagsObservable) {\n    if (tagsObservable.contains(newTag)) {\n      return;\n    }\n    tagsObservable.add(newTag);\n  }\n  firePropertyChange(\"tag\",null,tagsObservable);\n}\n", "nl": "Adds the tag."}
{"code": "public EObject basicGetAstElement(){\n  return astElement;\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public void detach(){\n  if (systemOverlay) {\n    getWindowManager().removeView(this);\n  }\n else {\n    ((ViewGroup)getActivityContentView()).removeView(this);\n  }\n}\n", "nl": "Detaches it from the container view."}
{"code": "private static void patternCompile(){\n  try {\n    ptnNumber=Pattern.compile(strNumberPattern);\n    ptnShortDate=Pattern.compile(strShortDatePattern);\n    ptnLongDate=Pattern.compile(strLongDatePattern);\n    ptnPercentage=Pattern.compile(strPercentagePattern);\n    ptnCurrency=Pattern.compile(strCurrencyPattern);\n    ptnViCurrency=Pattern.compile(strViCurrencyPattern);\n  }\n catch (  PatternSyntaxException ex) {\n    System.err.println(ex.getMessage());\n    System.exit(1);\n  }\n}\n", "nl": "Pattern compile."}
{"code": "public NotificationChain basicSetParams(ExpressionList newParams,NotificationChain msgs){\n  ExpressionList oldParams=params;\n  params=newParams;\n  if (eNotificationRequired()) {\n    ENotificationImpl notification=new ENotificationImpl(this,Notification.SET,GamlPackage.PARAMETERS__PARAMS,oldParams,newParams);\n    if (msgs == null)     msgs=notification;\n else     msgs.add(notification);\n  }\n  return msgs;\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "static public int unpackInt(DataInput is) throws IOException {\n  int ret=0;\n  byte v;\n  do {\n    v=is.readByte();\n    ret=(ret << 7) | (v & 0x7F);\n  }\n while ((v & 0x80) == 0);\n  return ret;\n}\n", "nl": "Unpack int value from the input stream."}
{"code": "public Object loadWorkflowData(String stepId,String key){\n  Object data=null;\n  String workflowUri=getMainWorkflowUri(stepId);\n  try {\n    if (workflowUri != null) {\n      String dataPath=String.format(_zkStepDataPath,workflowUri) + String.format(_zkWorkflowData,key);\n      if (_dataManager.checkExists(dataPath) != null) {\n        data=_dataManager.getData(dataPath,false);\n      }\n    }\n  }\n catch (  Exception ex) {\n    String exMsg=\"Exception adding global data to workflow from stepId: \" + stepId + \": \"+ ex.getMessage();\n    _log.error(exMsg);\n    data=null;\n  }\n  return data;\n}\n", "nl": "Gets the step workflow data stored under /workflow/stepdata/{workflowURI}/data/{key} where workflowURI is the URI of the main workflow regardless of whether the step belongs in the main workflow or one of its nested workflows."}
{"code": "public static void fillByte(byte[] array,byte x){\n  for (int i=0; i < array.length; i++) {\n    array[i]=x;\n  }\n}\n", "nl": "Fill an array with the given value."}
{"code": "@Override public void addDictionaryChunk(List<byte[]> dictionaryChunk){\n  dictionaryChunks.add(dictionaryChunk);\n  if (null == dictionaryByteArrayToSurrogateKeyMap) {\n    createDictionaryByteArrayToSurrogateKeyMap(dictionaryChunk.size());\n  }\n  addDataToDictionaryMap();\n}\n", "nl": "This method will add a new dictionary chunk to existing list of dictionary chunks"}
{"code": "public OMWarpingImage(BufferedImage bi){\n  setWarp(bi,LatLonGCT.INSTANCE,new DataBounds(-180,-90,180,90));\n}\n", "nl": "Takes an image, assumed to be a world image in the LLXY projection (equal arc) covering -180, 180 longitude to -90, 90 latitude."}
{"code": "private void acquirePrecachingWakeLock(){\n  if (mPrecachingWakeLock == null) {\n    PowerManager pm=(PowerManager)getSystemService(Context.POWER_SERVICE);\n    mPrecachingWakeLock=pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,TAG);\n  }\n  mPrecachingWakeLock.acquire();\n}\n", "nl": "Acquire the precaching WakeLock."}
{"code": "public static List<Long> entropyHybridTest(GeoTimeSerie gts,int buckets_per_period,int periods_per_piece,int k,double alpha) throws WarpScriptException {\n  doubleCheck(gts);\n  List<Long> anomalous_ticks=new ArrayList<Long>();\n  if (!GTSHelper.isBucketized(gts)) {\n    throw new WarpScriptException(\"GTS must be bucketized\");\n  }\n  if (k >= periods_per_piece * buckets_per_period / 2) {\n    throw new WarpScriptException(\"Upper bound of number of outliers must be less than half of the number of observations per piece\");\n  }\n  GeoTimeSerie subgts=null;\n  GeoTimeSerie subsubgts=null;\n  GeoTimeSerie seasonal=null;\n  long pieces=gts.bucketcount / buckets_per_period / periods_per_piece;\n  int bpp=periods_per_piece * buckets_per_period;\n  long lb=gts.lastbucket;\n  long bs=gts.bucketspan;\n  for (int u=0; u < pieces; u++) {\n    long start=lb - bs * ((pieces - u) * bpp - 1);\n    long stop=lb - bs * (pieces - u - 1) * bpp;\n    subgts=GTSHelper.subSerie(gts,start,stop,false,false,subgts);\n    subgts.lastbucket=stop;\n    subgts.bucketcount=bpp;\n    subgts.bucketspan=bs;\n    if (null == seasonal) {\n      seasonal=new GeoTimeSerie(bpp);\n      seasonal.doubleValues=new double[bpp];\n      seasonal.ticks=new long[bpp];\n    }\n else {\n      GTSHelper.reset(seasonal);\n    }\n    seasonal.type=TYPE.DOUBLE;\n    for (int v=0; v < buckets_per_period; v++) {\n      subsubgts=GTSHelper.subCycleSerie(subgts,stop - v * bs,buckets_per_period,true,subsubgts);\n      double[] madsigma=madsigma(subsubgts,true);\n      double median=madsigma[0];\n      double mad=madsigma[1];\n      double sum=0.0D;\n      for (int w=0; w < subsubgts.values; w++) {\n        subsubgts.doubleValues[w]=0.0D != mad ? Math.abs((subsubgts.doubleValues[w] - median) / mad) : 1.0D;\n        sum+=subsubgts.doubleValues[w];\n      }\n      double entropy=0.0D;\n      for (int w=0; w < subsubgts.values; w++) {\n        subsubgts.doubleValues[w]/=sum;\n        double tmp=subsubgts.doubleValues[w];\n        if (0.0D != tmp) {\n          entropy-=tmp * Math.log(tmp);\n        }\n      }\n      if (0.0D != entropy) {\n        entropy/=Math.log(subsubgts.values);\n      }\n else {\n        entropy=1.0D;\n      }\n      for (int w=0; w < subsubgts.values; w++) {\n        GTSHelper.setValue(seasonal,subsubgts.ticks[w],entropy * subsubgts.doubleValues[w]);\n      }\n    }\n    GTSHelper.sort(seasonal);\n    double m=median(seasonal);\n    int idx=0;\n    for (int i=0; i < subgts.values; i++) {\n      idx=Arrays.binarySearch(seasonal.ticks,idx,seasonal.values,subgts.ticks[i]);\n      if (idx < 0) {\n        throw new WarpScriptException(\"Internal bug method entropyHybridTest: can't find tick \" + subgts.ticks[i] + \" in seasonal.ticks\");\n      }\n else {\n        subgts.doubleValues[i]-=(seasonal.doubleValues[idx] + m);\n      }\n    }\n    anomalous_ticks.addAll(ESDTest(subgts,k,true,alpha));\n  }\n  return anomalous_ticks;\n}\n", "nl": "Applying Seasonal Entropy Hybrid test This test is based on piecewise decomposition where trend components are approximated by median and seasonal components by entropy of the cycle sub-series. An ESD test is passed upon the residuals. It differs from hybridTest by approximating seasonal component instead of using STL. But in many cases this approximation is more useful than estimation of STL."}
{"code": "public static void collectAndFireTriggers(final HashSet<PlayerID> players,final Match<TriggerAttachment> triggerMatch,final IDelegateBridge aBridge,final String beforeOrAfter,final String stepName){\n  final HashSet<TriggerAttachment> toFirePossible=collectForAllTriggersMatching(players,triggerMatch,aBridge);\n  if (toFirePossible.isEmpty()) {\n    return;\n  }\n  final HashMap<ICondition,Boolean> testedConditions=collectTestsForAllTriggers(toFirePossible,aBridge);\n  final List<TriggerAttachment> toFireTestedAndSatisfied=Match.getMatches(toFirePossible,AbstractTriggerAttachment.isSatisfiedMatch(testedConditions));\n  if (toFireTestedAndSatisfied.isEmpty()) {\n    return;\n  }\n  TriggerAttachment.fireTriggers(new HashSet<>(toFireTestedAndSatisfied),testedConditions,aBridge,beforeOrAfter,stepName,true,true,true,true);\n}\n", "nl": "This will collect all triggers for the desired players, based on a match provided, and then it will gather all the conditions necessary, then test all the conditions, and then it will fire all the conditions which are satisfied."}
{"code": "public static long[] clone(long[] array){\n  if (array == null) {\n    return null;\n  }\n  return (long[])array.clone();\n}\n", "nl": "<p>Clones an array returning a typecast result and handling <code>null</code>.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>"}
{"code": "public ColorPredicate(String input) throws IllegalArgumentException {\n  String rest=input.trim().toLowerCase();\n  if (rest.startsWith(\"leaf\")) {\n    this.isLeaf=true;\n    rest=rest.substring(4).trim();\n  }\n else {\n    this.isLeaf=false;\n  }\n  int endOfStartToken=0;\n  while (endOfStartToken < rest.length() && Character.isLetter(rest.charAt(endOfStartToken))) {\n    endOfStartToken++;\n  }\n  String startToken=rest.substring(0,endOfStartToken);\n  String macro=getMacro(startToken);\n  if (macro != null) {\n    rest=macro;\n  }\n  if (rest.startsWith(\"some\")) {\n    this.isSome=true;\n    rest=rest.substring(4).trim();\n  }\n else   if (rest.startsWith(\"every\")) {\n    this.isSome=false;\n    rest=rest.substring(5).trim();\n  }\n else {\n    throw new IllegalArgumentException(\"\" + \" Color predicate must start with the optional keyword `leaf'\\n\" + \" followed by a legal macro name or `every' or `some'.\");\n  }\n  this.set=0;\n  while (!rest.equals(\"\")) {\n    if (rest.startsWith(\"omitted\")) {\n      this.set=this.set | (1 << NUMBER_OF_OMITTED_STATE);\n      rest=rest.substring(7).trim();\n    }\n else     if (rest.startsWith(\"missing\")) {\n      this.set=this.set | (1 << NUMBER_OF_MISSING_STATE);\n      rest=rest.substring(7).trim();\n    }\n else     if (rest.startsWith(\"(\")) {\n      rest=rest.substring(1).trim();\n      int[][] stateSetSpec=new int[NUMBER_OF_PROVERS][];\n      for (int i=0; i < NUMBER_OF_PROVERS; i++) {\n        boolean invert=false;\n        if (rest.startsWith(\"-\")) {\n          invert=true;\n          rest=rest.substring(1).trim();\n        }\n        boolean[] appears=new boolean[PROVER_STATUSES[i].length];\n        for (int j=0; j < appears.length; j++) {\n          appears[j]=invert;\n        }\n        String endChar=(i == NUMBER_OF_PROVERS - 1) ? \")\" : \",\";\n        while (rest.length() > 0 && !rest.startsWith(endChar)) {\n          int endOfToken=0;\n          while (endOfToken < rest.length() && Character.isLetter(rest.charAt(endOfToken))) {\n            endOfToken++;\n          }\n          String token=rest.substring(0,endOfToken);\n          rest=rest.substring(endOfToken).trim();\n          int statusNumber;\n          try {\n            statusNumber=numberOfProverStatus(i,token);\n          }\n catch (          IllegalArgumentException e) {\n            String errorMsg=\"Was expecting status of prover \" + PROVER_NAMES[i] + \" but found `\"+ token+ \"' followed by: \\n `\"+ rest+ \"'\";\n            throw new IllegalArgumentException(errorMsg);\n          }\n          appears[statusNumber]=!invert;\n        }\n        if (rest.length() == 0) {\n          throw new IllegalArgumentException(\"Color predicate specifier ended before `(...)' expression complete\");\n        }\n        rest=rest.substring(1).trim();\n        int count=0;\n        for (int j=0; j < appears.length; j++) {\n          if (appears[j]) {\n            count++;\n          }\n        }\n        if (count == 0) {\n          if (invert) {\n            throw new IllegalArgumentException(\"A `-' must be followed by one or more statuses\");\n          }\n else {\n            count=appears.length;\n            for (int j=0; j < count; j++) {\n              appears[j]=true;\n            }\n          }\n        }\n        stateSetSpec[i]=new int[count];\n        int k=0;\n        for (int j=0; j < appears.length; j++) {\n          if (appears[j]) {\n            stateSetSpec[i][k]=j;\n            k++;\n          }\n        }\n      }\n      this.set=this.set | bitVectorOfStates(stateSetSpec);\n    }\n else {\n      throw new IllegalArgumentException(\"Unexpected token at: `\" + rest + \"'\");\n    }\n  }\n}\n", "nl": "Returns a ColorPredicate obtained by parsing its argument. See the beginning of ProofStatus.tla for the grammar of the input."}
{"code": "protected void transferFromFile(File idFile) throws IOException {\n  try (BufferedReader br=new BufferedReader(new FileReader(idFile))){\n    String line;\n    while ((line=br.readLine()) != null) {\n      line=line.trim();\n      if (line.length() > 0) {\n        transfer(line);\n      }\n    }\n  }\n }\n", "nl": "Transfer all the sequences listed in the supplied file, interpreting entries appropriately."}
{"code": "public String toNamespacedString(){\n  return (_namespaceURI != null ? (\"{\" + _namespaceURI + \"}\"+ _localName) : _localName);\n}\n", "nl": "Return the string representation of the qualified name using the  the '{ns}foo' notation. Performs string concatenation, so beware of performance issues."}
{"code": "@SuppressWarnings(\"deprecation\") public void configureManagers(){\n  powerManager=new jmri.jmrix.nce.NcePowerManager(this);\n  InstanceManager.store(powerManager,jmri.PowerManager.class);\n  turnoutManager=new jmri.jmrix.nce.NceTurnoutManager(getNceTrafficController(),getSystemPrefix());\n  InstanceManager.setTurnoutManager(turnoutManager);\n  lightManager=new jmri.jmrix.nce.NceLightManager(getNceTrafficController(),getSystemPrefix());\n  InstanceManager.setLightManager(lightManager);\n  sensorManager=new jmri.jmrix.nce.NceSensorManager(getNceTrafficController(),getSystemPrefix());\n  InstanceManager.setSensorManager(sensorManager);\n  throttleManager=new jmri.jmrix.nce.NceThrottleManager(this);\n  InstanceManager.setThrottleManager(throttleManager);\n  if (getNceUsbSystem() != NceTrafficController.USB_SYSTEM_NONE) {\n    if (getNceUsbSystem() != NceTrafficController.USB_SYSTEM_POWERHOUSE) {\n    }\n  }\n else {\n    InstanceManager.setProgrammerManager(getProgrammerManager());\n  }\n  clockManager=new jmri.jmrix.nce.NceClockControl(getNceTrafficController(),getSystemPrefix());\n  InstanceManager.addClockControl(clockManager);\n  consistManager=new jmri.jmrix.nce.NceConsistManager(this);\n  InstanceManager.setConsistManager(consistManager);\n}\n", "nl": "Configure the common managers for NCE connections. This puts the common manager config in one place."}
{"code": "public void newLine() throws IOException {\n  out.append('\\n');\n  for (int n=0; n < currentIndentLevel; n++)   out.append(indent);\n  currentLine++;\n  currentCol=currentIndentLevel * indent.length();\n}\n", "nl": "Emits a <code>'\\n'</code> plus required indentation characters for the current indentation level."}
{"code": "@Override protected void checkForDuplicatSnapshotName(String name,Volume vplexVolume){\n  Volume snapshotSourceVolume=getVPLEXSnapshotSourceVolume(vplexVolume);\n  super.checkForDuplicatSnapshotName(name,snapshotSourceVolume);\n}\n", "nl": "Check if a snapshot with the same name exists for the passed volume."}
{"code": "public boolean isOneAssetPerUOM(){\n  Object oo=get_Value(COLUMNNAME_IsOneAssetPerUOM);\n  if (oo != null) {\n    if (oo instanceof Boolean)     return ((Boolean)oo).booleanValue();\n    return \"Y\".equals(oo);\n  }\n  return false;\n}\n", "nl": "Get One Asset Per UOM."}
{"code": "public int value(){\n  return this.value;\n}\n", "nl": "Retrieve value for node computed so far. <p> Primarily here for testing"}
{"code": "public boolean isRemove(){\n  boolean is;\n  if (m_editFlag == FolderEditFlag.REMOVE)   is=true;\n else   is=false;\n  return is;\n}\n", "nl": "Devuelve <tt>true</tt> si el campo est? marcado como eliminado"}
{"code": "public static String encodeWebSafe(byte[] source,boolean doPadding){\n  return encode(source,0,source.length,WEBSAFE_ALPHABET,doPadding);\n}\n", "nl": "Encodes a byte array into web safe Base64 notation."}
{"code": "@Override public void commence(HttpServletRequest request,HttpServletResponse response,AuthenticationException arg2) throws IOException, ServletException {\n  log.debug(\"Pre-authenticated entry point called. Rejecting access\");\n  response.sendError(HttpServletResponse.SC_UNAUTHORIZED,\"Access Denied\");\n}\n", "nl": "Always returns a 401 error code to the client."}
{"code": "public int size(){\n  return _size;\n}\n", "nl": "Returns the current number of entries in the map."}
{"code": "private List<Volume> createVolumeData(String name,int numVolumes){\n  List<Volume> volumes=new ArrayList<Volume>();\n  URI cgUri=createBlockConsistencyGroup(name + \"-cg\");\n  for (int i=1; i <= numVolumes; i++) {\n    Volume volume=new Volume();\n    URI volumeURI=URIUtil.createId(Volume.class);\n    testVolumeURIs.add(volumeURI);\n    volume.setId(volumeURI);\n    volume.setLabel(name + i);\n    volume.setConsistencyGroup(cgUri);\n    _dbClient.createObject(volume);\n  }\n  return volumes;\n}\n", "nl": "Creates the BlockObject Volume data."}
{"code": "private void showFeedback(String message){\n  if (myHost != null) {\n    myHost.showFeedback(message);\n  }\n else {\n    System.out.println(message);\n  }\n}\n", "nl": "Used to communicate feedback pop-up messages between a plugin tool and the main Whitebox user-interface."}
{"code": "public static void closeStream(Closeable stream){\n  if (stream != null) {\n    try {\n      stream.close();\n    }\n catch (    IOException e) {\n      android.util.Log.e(\"IO\",\"Could not close stream\",e);\n    }\n  }\n}\n", "nl": "Closes the specified stream."}
{"code": "private static BufferedImage loadImage(final IdocScanInterface ui,int finalWidth,int finalHeight){\n  return loadImage(ui,finalWidth,finalHeight,0);\n}\n", "nl": "Muestra la imagen seleccionada de la lista en el visor del applet a escala real"}
{"code": "private void updateProgress(String progressLabel,int progress){\n  if (myHost != null && ((progress != previousProgress) || (!progressLabel.equals(previousProgressLabel)))) {\n    myHost.updateProgress(progressLabel,progress);\n  }\n  previousProgress=progress;\n  previousProgressLabel=progressLabel;\n}\n", "nl": "Used to communicate a progress update between a plugin tool and the main Whitebox user interface."}
{"code": "public void configure(){\n  XpaSystemConnectionMemo memo=((XpaSystemConnectionMemo)getSystemConnectionMemo());\n  XpaTrafficController tc=memo.getXpaTrafficController();\n  tc.connectPort(this);\n  memo.setPowerManager(new jmri.jmrix.xpa.XpaPowerManager(tc));\n  jmri.InstanceManager.store(memo.getPowerManager(),jmri.PowerManager.class);\n  memo.setTurnoutManager(new jmri.jmrix.xpa.XpaTurnoutManager(memo));\n  jmri.InstanceManager.store(memo.getTurnoutManager(),jmri.TurnoutManager.class);\n  memo.setThrottleManager(new jmri.jmrix.xpa.XpaThrottleManager(memo));\n  jmri.InstanceManager.store(memo.getThrottleManager(),jmri.ThrottleManager.class);\n  tc.startTransmitThread();\n  sinkThread=new Thread(tc);\n  sinkThread.start();\n}\n", "nl": "set up all of the other objects to operate with an XPA+Modem Connected to an XPressNet based command station connected to this port"}
{"code": "public void executeQuery(IMiniTable miniTable){\n  log.info(\"\");\n  String sql=\"\";\n  if (m_DD_Order_ID == null)   return;\n  sql=getOrderSQL();\n  log.fine(sql);\n  int row=0;\n  miniTable.setRowCount(row);\n  try {\n    PreparedStatement pstmt=DB.prepareStatement(sql.toString(),null);\n    pstmt.setInt(1,Integer.parseInt(m_DD_Order_ID.toString()));\n    ResultSet rs=pstmt.executeQuery();\n    while (rs.next()) {\n      miniTable.setRowCount(row + 1);\n      miniTable.setValueAt(new IDColumn(rs.getInt(1)),row,0);\n      miniTable.setValueAt(rs.getBigDecimal(2),row,1);\n      miniTable.setValueAt(rs.getString(3),row,2);\n      miniTable.setValueAt(rs.getString(4),row,4);\n      miniTable.setValueAt(rs.getString(5),row,3);\n      miniTable.setValueAt(rs.getString(6),row,5);\n      row++;\n    }\n    rs.close();\n    pstmt.close();\n  }\n catch (  SQLException e) {\n    log.log(Level.SEVERE,sql.toString(),e);\n  }\n  miniTable.autoSize();\n}\n", "nl": "Query Info"}
{"code": "public ParameterDatabase(){\n  super();\n  accessed=new Hashtable();\n  gotten=new Hashtable();\n  directory=new File(new File(\"\").getAbsolutePath());\n  label=\"Basic Database\";\n  parents=new Vector();\n  checked=false;\n}\n", "nl": "Creates an empty parameter database."}
{"code": "private CTagHelpers(){\n}\n", "nl": "You are not supposed to instantiate this class."}
{"code": "public EventSourceImpl(){\n  LOG.entering(CLASS_NAME,\"<init>\");\n}\n", "nl": "EventSource provides a text-based stream abstraction for Java"}
{"code": "@DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 13:01:25.281 -0500\",hash_original_method=\"8F9A0D25038BAA53AA87BFFA0D47316A\",hash_generated_method=\"D647B858B68B1333AC193E85FEBDEE73\") public static void registrationComplete(){\nsynchronized (mHandlerMap) {\n    mRegistrationComplete=true;\n    mHandlerMap.notifyAll();\n  }\n}\n", "nl": "The application must call here after it finishes registering handlers."}
{"code": "public long next(){\n  return next(RecurrenceUtil.now());\n}\n", "nl": "Returns the next recurrence from now."}
{"code": "@Override public void writeExternal(ObjectOutput out) throws IOException {\n  super.writeExternal(out);\n  mbr.writeExternal(out);\n}\n", "nl": "Calls the super method and writes the MBR object of this entry to the specified output stream."}
{"code": "protected void validate_return(StorageCapability[] param){\n}\n", "nl": "validate the array for _return"}
{"code": "public static String jQuote(String s){\n  if (s == null) {\n    return \"null\";\n  }\n  int ln=s.length();\n  StringBuilder b=new StringBuilder(ln + 4);\n  b.append('\"');\n  for (int i=0; i < ln; i++) {\n    char c=s.charAt(i);\n    if (c == '\"') {\n      b.append(\"\\\\\\\"\");\n    }\n else     if (c == '\\\\') {\n      b.append(\"\\\\\\\\\");\n    }\n else     if (c < 0x20) {\n      if (c == '\\n') {\n        b.append(\"\\\\n\");\n      }\n else       if (c == '\\r') {\n        b.append(\"\\\\r\");\n      }\n else       if (c == '\\f') {\n        b.append(\"\\\\f\");\n      }\n else       if (c == '\\b') {\n        b.append(\"\\\\b\");\n      }\n else       if (c == '\\t') {\n        b.append(\"\\\\t\");\n      }\n else {\n        b.append(\"\\\\u00\");\n        int x=c / 0x10;\n        b.append(toHexDigit(x));\n        x=c & 0xF;\n        b.append(toHexDigit(x));\n      }\n    }\n else {\n      b.append(c);\n    }\n  }\n  b.append('\"');\n  return b.toString();\n}\n", "nl": "Quotes string as Java Language string literal. Returns string <code>\"null\"</code> if <code>s</code> is <code>null</code>."}
{"code": "public FluentFunction<T3,R> partiallyApply(final T1 param1,final T2 param2){\n  return new FluentFunction<>(PartialApplicator.partial3(param1,param2,fn));\n}\n", "nl": "Partially apply the provided parameters to this BiFunction to generate a Function (single input)"}
{"code": "public static boolean deleteFile(String path){\n  if (Handler_String.isBlank(path)) {\n    return true;\n  }\n  File file=new File(path);\n  if (!file.exists()) {\n    return true;\n  }\n  if (file.isFile()) {\n    return file.delete();\n  }\n  if (!file.isDirectory()) {\n    return false;\n  }\n  for (  File f : file.listFiles()) {\n    if (f.isFile()) {\n      f.delete();\n    }\n else     if (f.isDirectory()) {\n      deleteFile(f.getAbsolutePath());\n    }\n  }\n  return file.delete();\n}\n", "nl": "delete file or directory <ul> <li>if path is null or empty, return true</li> <li>if path not exist, return true</li> <li>if path exist, delete recursion. return true</li> <ul>"}
{"code": "private ImmutableSet<CassandraJmxCompactionClient> createCompactionClients(CassandraJmxCompactionConfig jmxConfig){\n  Set<CassandraJmxCompactionClient> clients=Sets.newHashSet();\n  Set<InetSocketAddress> servers=config.servers();\n  int jmxPort=jmxConfig.port();\n  for (  InetSocketAddress addr : servers) {\n    CassandraJmxCompactionClient client=createCompactionClient(addr.getHostString(),jmxPort,jmxConfig.username(),jmxConfig.password());\n    clients.add(client);\n  }\n  return ImmutableSet.copyOf(clients);\n}\n", "nl": "Return an empty set if no client can be created."}
{"code": "public static String hashKeyForDisk(String key){\n  String cacheKey;\n  try {\n    final MessageDigest mDigest=MessageDigest.getInstance(\"MD5\");\n    mDigest.update(key.getBytes());\n    cacheKey=bytesToHexString(mDigest.digest());\n  }\n catch (  NoSuchAlgorithmException e) {\n    cacheKey=String.valueOf(key.hashCode());\n  }\n  return cacheKey;\n}\n", "nl": "A hashing method that changes a string (like a URL) into a hash suitable for using as a disk filename."}
{"code": "@Nullable public String space(){\n  return space;\n}\n", "nl": "Gets swap space name."}
{"code": "public Object runSafely(Catbert.FastStack stack) throws Exception {\n  SeriesInfo si=getSeriesInfo(stack);\n  return si == null ? \"\" : si.getDescription();\n}\n", "nl": "Returns the description for the specified SeriesInfo"}
{"code": "public UserEntry restoreUser(String username) throws AppsForYourDomainException, ServiceException, IOException {\n  LOGGER.log(Level.INFO,\"Restoring user '\" + username + \"'.\");\n  URL retrieveUrl=new URL(domainUrlBase + \"user/\" + SERVICE_VERSION+ \"/\"+ username);\n  UserEntry userEntry=userService.getEntry(retrieveUrl,UserEntry.class);\n  userEntry.getLogin().setSuspended(false);\n  URL updateUrl=new URL(domainUrlBase + \"user/\" + SERVICE_VERSION+ \"/\"+ username);\n  return userService.update(updateUrl,userEntry);\n}\n", "nl": "Restores a user. Note that executing this method for a user who is not suspended has no effect."}
{"code": "private Class(RVMType type){\n  this.type=type;\n}\n", "nl": "Prevents this class from being instantiated, except by the create method in this class."}
{"code": "public double weightedFMeasure(){\n  double[] classCounts=new double[m_NumClasses];\n  double classCountSum=0;\n  for (int i=0; i < m_NumClasses; i++) {\n    for (int j=0; j < m_NumClasses; j++) {\n      classCounts[i]+=m_ConfusionMatrix[i][j];\n    }\n    classCountSum+=classCounts[i];\n  }\n  double fMeasureTotal=0;\n  for (int i=0; i < m_NumClasses; i++) {\n    double temp=fMeasure(i);\n    fMeasureTotal+=(temp * classCounts[i]);\n  }\n  return fMeasureTotal / classCountSum;\n}\n", "nl": "Calculates the macro weighted (by class size) average F-Measure."}
{"code": "@DSSafe(DSCat.DATA_STRUCTURE) @DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 12:55:08.711 -0500\",hash_original_method=\"05A7D65C6D911E0B1F3261A66888CB52\",hash_generated_method=\"3AFFFBA2DDE5D54646A6F203B3BBAF40\") public int lastIndexOf(Object obj){\n  return this.hlist.lastIndexOf(obj);\n}\n", "nl": "Get the last index of the given object."}
{"code": "public Builder showNextButton(boolean showNextButton){\n  this.showNextButton=showNextButton;\n  return this;\n}\n", "nl": "Set the visibility of the next button"}
{"code": "public static ValueLobDb createSmallLob(int type,byte[] small,long precision){\n  return new ValueLobDb(type,small,precision);\n}\n", "nl": "Create a LOB object that fits in memory."}
{"code": "public void invDct8x8(double[][] input,int[][] output){\n  double[][] temp=new double[NJPEG][NJPEG];\n  double temp1=0.0;\n  int i=0;\n  int j=0;\n  int k=0;\n  for (i=0; i < NJPEG; i++) {\n    for (j=0; j < NJPEG; j++) {\n      temp[i][j]=0.0;\n      for (k=0; k < NJPEG; k++) {\n        temp[i][j]+=input[i][k] * this.C[k][j];\n      }\n    }\n  }\n  for (i=0; i < NJPEG; i++) {\n    for (j=0; j < NJPEG; j++) {\n      temp1=0.0;\n      for (k=0; k < NJPEG; k++) {\n        temp1+=this.Ct[i][k] * temp[k][j];\n      }\n      temp1+=128.0;\n      output[i][j]=ImageUtil.pixelRange(round(temp1));\n    }\n  }\n}\n", "nl": "Perform inverse DCT on the 8x8 matrix"}
{"code": "public static InputStream openDataFile(){\n  InputStream stream=SantaFeExample.class.getResourceAsStream(\"santafe.trail\");\n  if (stream == null) {\n    System.err.println(\"Unable to find the file santafe.trail.\");\n    System.exit(-1);\n  }\n  return stream;\n}\n", "nl": "Returns an input stream that contains the ant trail data file."}
{"code": "public ProductionRule(final String name,final GameData data,final IntegerMap<NamedAttachable> results,final IntegerMap<Resource> costs){\n  super(name,data);\n  m_results=results;\n  m_cost=costs;\n}\n", "nl": "Creates new ProductionRule"}
{"code": "public RootConfiguration(ApplicationInformation ai){\n  this(ai,getDefaultContexts(applicationClass(ai,CommonUtils.getCallingClass(2))));\n}\n", "nl": "Initializes the root configuration with default context relative to the calling (instantiating class)."}
{"code": "public void addString(String word,Tuple t){\n  TrieLeaf leaf=new TrieLeaf(word,t);\n  addLeaf(root,leaf,0);\n}\n", "nl": "Add a new word to the trie, associated with the given Tuple."}
{"code": "public void waitOnInitialization() throws InterruptedException {\n  this.initializationLatch.await();\n}\n", "nl": "Wait for the tracker to finishe being initialized"}
{"code": "@Override public Object execute(ExecutionEvent event) throws ExecutionException {\n  IWorkbenchPart viewPart=HandlerUtil.getActivePart(event);\n  if (viewPart instanceof DroidsafeInfoOutlineViewPart) {\n    Command command=event.getCommand();\n    boolean oldValue=HandlerUtil.toggleCommandState(command);\n    ((DroidsafeInfoOutlineViewPart)viewPart).setLongLabel(!oldValue);\n  }\n  return null;\n}\n", "nl": "Command implementation. Retrieves the value of the parameter value, and delegates to the view to set the correct value for the methods labels."}
{"code": "@Override protected EClass eStaticClass(){\n  return UmplePackage.eINSTANCE.getCodeLang_();\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "private static byte[] streamToBytes(InputStream in,int length) throws IOException {\n  byte[] bytes=new byte[length];\n  int count;\n  int pos=0;\n  while (pos < length && ((count=in.read(bytes,pos,length - pos)) != -1)) {\n    pos+=count;\n  }\n  if (pos != length) {\n    throw new IOException(\"Expected \" + length + \" bytes, read \"+ pos+ \" bytes\");\n  }\n  return bytes;\n}\n", "nl": "Reads the contents of an InputStream into a byte[]."}
{"code": "public void testUpdatePathDoesNotExist() throws Exception {\n  final Map<String,String> props=properties(\"owner\",\"group\",\"0555\");\n  assert igfs.update(SUBDIR,props) == null;\n  checkNotExist(igfs,igfsSecondary,SUBDIR);\n}\n", "nl": "Check that exception is thrown in case the path being updated doesn't exist remotely."}
{"code": "public void stopProcess() throws InterruptedException {\n  latch.await();\n  if (this.process != null) {\n    System.out.println(\"ProcessThread.stopProcess() will kill process\");\n    this.process.destroy();\n  }\n}\n", "nl": "Stops the process."}
{"code": "@Override public void run(){\n  amIActive=true;\n  String inputHeader=null;\n  String outputHeader=null;\n  int row, col, x, y;\n  int progress=0;\n  double z;\n  int i, c;\n  int[] dX=new int[]{1,1,1,0,-1,-1,-1,0};\n  int[] dY=new int[]{-1,0,1,1,1,0,-1,-1};\n  double zFactor=0;\n  double slopeThreshold=0;\n  double profCurvThreshold=0;\n  double planCurvThreshold=0;\n  double radToDeg=180 / Math.PI;\n  if (args.length <= 0) {\n    showFeedback(\"Plugin parameters have not been set.\");\n    return;\n  }\n  for (i=0; i < args.length; i++) {\n    if (i == 0) {\n      inputHeader=args[i];\n    }\n else     if (i == 1) {\n      outputHeader=args[i];\n    }\n else     if (i == 2) {\n      zFactor=Double.parseDouble(args[i]);\n    }\n else     if (i == 3) {\n      slopeThreshold=Double.parseDouble(args[i]);\n    }\n else     if (i == 4) {\n      profCurvThreshold=Double.parseDouble(args[i]);\n    }\n else     if (i == 5) {\n      planCurvThreshold=Double.parseDouble(args[i]);\n    }\n  }\n  if ((inputHeader == null) || (outputHeader == null)) {\n    showFeedback(\"One or more of the input parameters have not been set properly.\");\n    return;\n  }\n  try {\n    WhiteboxRaster DEM=new WhiteboxRaster(inputHeader,\"r\");\n    int rows=DEM.getNumberRows();\n    int cols=DEM.getNumberColumns();\n    double noData=DEM.getNoDataValue();\n    double gridResX=DEM.getCellSizeX();\n    double gridResY=DEM.getCellSizeY();\n    double diagGridRes=Math.sqrt(gridResX * gridResX + gridResY * gridResY);\n    double[] gridLengths=new double[]{diagGridRes,gridResX,diagGridRes,gridResY,diagGridRes,gridResX,diagGridRes,gridResY};\n    double Zx, Zy, Zxx, Zyy, Zxy, p, Zx2, q, Zy2;\n    double fx, fy;\n    double gridResTimes2=gridResX * 2;\n    double gridResSquared=gridResX * gridResX;\n    double fourTimesGridResSquared=gridResSquared * 4;\n    double planCurv, profCurv, slope;\n    double eightGridRes=8 * gridResX;\n    double[] N=new double[8];\n    WhiteboxRaster output=new WhiteboxRaster(outputHeader,\"rw\",inputHeader,WhiteboxRaster.DataType.FLOAT,-999);\n    output.setPreferredPalette(\"landclass.pal\");\n    output.setDataScale(WhiteboxRaster.DataScale.CONTINUOUS);\n    for (row=0; row < rows; row++) {\n      for (col=0; col < cols; col++) {\n        z=DEM.getValue(row,col);\n        if (z != noData) {\n          z=z * zFactor;\n          for (c=0; c < 8; c++) {\n            N[c]=DEM.getValue(row + dY[c],col + dX[c]);\n            if (N[c] != noData) {\n              N[c]=N[c] * zFactor;\n            }\n else {\n              N[c]=z;\n            }\n          }\n          Zx=(N[1] - N[5]) / gridResTimes2;\n          Zy=(N[7] - N[3]) / gridResTimes2;\n          Zxx=(N[1] - 2 * z + N[5]) / gridResSquared;\n          Zyy=(N[7] - 2 * z + N[3]) / gridResSquared;\n          Zxy=(-N[6] + N[0] + N[4] - N[2]) / fourTimesGridResSquared;\n          Zx2=Zx * Zx;\n          Zy2=Zy * Zy;\n          p=Zx2 + Zy2;\n          q=p + 1;\n          if (p > 0) {\n            fy=(N[6] - N[4] + 2 * (N[7] - N[3]) + N[0] - N[2]) / eightGridRes;\n            fx=(N[2] - N[4] + 2 * (N[1] - N[5]) + N[0] - N[6]) / eightGridRes;\n            slope=Math.atan(Math.sqrt(fx * fx + fy * fy));\n            slope=slope * radToDeg;\n            planCurv=-1 * (Zxx * Zy2 - 2 * Zxy * Zx* Zy + Zyy * Zx2) / Math.pow(p,1.5);\n            planCurv=(planCurv * radToDeg);\n            profCurv=-1 * (Zxx * Zx2 + 2 * Zxy * Zx* Zy + Zyy * Zy2) / Math.pow(p * q,1.5);\n            profCurv=(profCurv * radToDeg);\n            if (profCurv < -profCurvThreshold && planCurv <= -planCurvThreshold & slope > slopeThreshold) {\n              output.setValue(row,col,1);\n            }\n else             if (profCurv < -profCurvThreshold && planCurv > planCurvThreshold && slope > slopeThreshold) {\n              output.setValue(row,col,2);\n            }\n else             if (profCurv > profCurvThreshold && planCurv <= planCurvThreshold && slope > slopeThreshold) {\n              output.setValue(row,col,3);\n            }\n else             if (profCurv > profCurvThreshold && planCurv > planCurvThreshold && slope > slopeThreshold) {\n              output.setValue(row,col,4);\n            }\n else             if (profCurv >= -profCurvThreshold && profCurv < profCurvThreshold && slope > slopeThreshold && planCurv <= -planCurvThreshold) {\n              output.setValue(row,col,5);\n            }\n else             if (profCurv >= -profCurvThreshold && profCurv < profCurvThreshold && slope > slopeThreshold && planCurv > planCurvThreshold) {\n              output.setValue(row,col,6);\n            }\n else             if (slope <= slopeThreshold) {\n              output.setValue(row,col,7);\n            }\n else {\n              output.setValue(row,col,noData);\n            }\n          }\n else {\n            output.setValue(row,col,noData);\n          }\n        }\n      }\n      if (cancelOp) {\n        cancelOperation();\n        return;\n      }\n      progress=(int)(100f * row / (rows - 1));\n      updateProgress(progress);\n    }\n    output.addMetadataEntry(\"Created by the \" + getDescriptiveName() + \" tool.\");\n    output.addMetadataEntry(\"Created on \" + new Date());\n    DEM.close();\n    output.close();\n    returnData(outputHeader);\n    String retstr=\"LANDFORM CLASSIFICATION KEY\\n\";\n    retstr+=\"\\nValue:\\tClass\";\n    retstr+=\"\\n1\\tConvergent Footslope\";\n    retstr+=\"\\n2\\tDivergent Footslope\";\n    retstr+=\"\\n3\\tConvergent Shoulder\";\n    retstr+=\"\\n4\\tDivergent Shoulder\";\n    retstr+=\"\\n5\\tConvergent Backslope\";\n    retstr+=\"\\n6\\tDivergent Backslope\";\n    retstr+=\"\\n7\\tLevel\";\n    returnData(retstr);\n  }\n catch (  OutOfMemoryError oe) {\n    myHost.showFeedback(\"An out-of-memory error has occurred during operation.\");\n  }\ncatch (  Exception e) {\n    myHost.showFeedback(\"An error has occurred during operation. See log file for details.\");\n    myHost.logException(\"Error in \" + getDescriptiveName(),e);\n  }\n finally {\n    updateProgress(\"Progress: \",0);\n    amIActive=false;\n    myHost.pluginComplete();\n  }\n}\n", "nl": "Used to execute this plugin tool."}
{"code": "public R reduce(R r1,R r2){\n  return r1;\n}\n", "nl": "Reduces two results into a combined result. The default implementation is to return the first parameter. The general contract of the method is that it may take any action whatsoever."}
{"code": "public void numParameters(int num) throws IOException {\n  output.write(num);\n}\n", "nl": "Writes <code>num_parameters</code> in <code>Runtime(In)VisibleParameterAnnotations_attribute</code>. This method must be followed by <code>num</code> calls to <code>numAnnotations()</code>."}
{"code": "public ResultFormatter(Object result){\n  this.result=result;\n  printHeader=true;\n}\n", "nl": "Creates a new formatter for a particular object."}
{"code": "@Override public Eval<String> join(){\n  return Eval.later(null);\n}\n", "nl": "Perform an asynchronous join operation"}
{"code": "public GetRequest type(@Nullable String type){\n  if (type == null) {\n    type=\"_all\";\n  }\n  this.type=type;\n  return this;\n}\n", "nl": "Sets the type of the document to fetch."}
{"code": "@Override public ImmutableSet<Entry<K,V>> entries(){\n  ImmutableSet<Entry<K,V>> result=entries;\n  return result == null ? (entries=new EntrySet<K,V>(this)) : result;\n}\n", "nl": "Returns an immutable collection of all key-value pairs in the multimap. Its iterator traverses the values for the first key, the values for the second key, and so on."}
{"code": "private int luminance(int r,int g,int b){\n  return (int)((0.299 * r) + (0.58 * g) + (0.11 * b));\n}\n", "nl": "Apply the luminance"}
{"code": "private void puntPlay(Team offense){\n  gameYardLine=(int)(100 - (gameYardLine + offense.getK(0).ratKickPow / 3 + 20 - 10 * Math.random()));\n  if (gameYardLine < 0) {\n    gameYardLine=20;\n  }\n  gameDown=1;\n  gameYardsNeed=10;\n  gamePoss=!gamePoss;\n  gameTime-=20 + 15 * Math.random();\n}\n", "nl": "Punt the ball if it is a 4th down and decided not to go for it. Will turnover possession."}
{"code": "private List<String[]> readSentence(BufferedReader aReader) throws IOException {\n  List<String[]> words=new ArrayList<String[]>();\n  String line;\n  boolean beginSentence=true;\n  while ((line=aReader.readLine()) != null) {\n    if (StringUtils.isBlank(line)) {\n      beginSentence=true;\n      break;\n    }\n    if (hasHeader && beginSentence) {\n      beginSentence=false;\n      continue;\n    }\n    String[] fields=line.split(columnSeparator.getValue());\n    if (!hasEmbeddedNamedEntity && fields.length != 2 + FORM) {\n      throw new IOException(String.format(\"Invalid file format. Line needs to have %d %s-separated fields: [%s]\",2 + FORM,columnSeparator.getName(),line));\n    }\n else     if (hasEmbeddedNamedEntity && fields.length != 3 + FORM) {\n      throw new IOException(String.format(\"Invalid file format. Line needs to have %d %s-separated fields: [%s]\",3 + FORM,columnSeparator.getName(),line));\n    }\n    words.add(fields);\n  }\n  if (line == null && words.isEmpty()) {\n    return null;\n  }\n else {\n    return words;\n  }\n}\n", "nl": "Read a single sentence."}
{"code": "public static ConditionOperand OVERFLOW_FROM_SUB(){\n  return new ConditionOperand(OVERFLOW_FROM_SUB);\n}\n", "nl": "Create the condition code operand for OVERFLOW_FROM_SUB"}
{"code": "protected void initCheckLists(){\n  List<IceMediaStream> streams=getStreamsWithPendingConnectivityEstablishment();\n  int streamCount=streams.size();\n  int maxCheckListSize=Integer.getInteger(StackProperties.MAX_CHECK_LIST_SIZE,DEFAULT_MAX_CHECK_LIST_SIZE);\n  int maxPerStreamSize=streamCount == 0 ? 0 : maxCheckListSize / streamCount;\n  for (  IceMediaStream stream : streams) {\n    logger.info(\"Init checklist for stream \" + stream.getName());\n    stream.setMaxCheckListSize(maxPerStreamSize);\n    stream.initCheckList();\n  }\n  if (streamCount > 0)   streams.get(0).getCheckList().computeInitialCheckListPairStates();\n}\n", "nl": "Creates, initializes and orders the list of candidate pairs that would be used for the connectivity checks for all components in this stream."}
{"code": "private void checkSearchables(ArrayList<SearchableInfo> searchablesList){\n  assertNotNull(searchablesList);\n  int count=searchablesList.size();\n  for (int ii=0; ii < count; ii++) {\n    SearchableInfo si=searchablesList.get(ii);\n    checkSearchable(si);\n  }\n}\n", "nl": "Generic health checker for an array of searchables. This is designed to pass for any semi-legal searchable, without knowing much about the format of the underlying data.  It's fairly easy for a non-compliant application to provide meta-data that will pass here (e.g. a non-existent suggestions authority)."}
{"code": "private void generateImplementsParcelableInterface(PsiClass targetPsiClass){\n  PsiJavaCodeReferenceElement referenceElement=factory.createReferenceFromText(PARCELABLE_CLASS_SIMPLE_NAME,null);\n  PsiReferenceList implementsList=targetPsiClass.getImplementsList();\n  if (null != implementsList) {\n    implementsList.add(referenceElement);\n  }\n  generateImportStatement(PARCELABLE_PACKAGE);\n  generateExtraMethods(targetPsiClass);\n}\n", "nl": "Implement android.os.Parcelable interface"}
{"code": "private RemoteDirectorGroup fetchRDFGroupFromCache(Map<URI,RemoteDirectorGroup> rdfGroupCache,URI srdfGroupURI){\n  if (rdfGroupCache.containsKey(srdfGroupURI)) {\n    return rdfGroupCache.get(srdfGroupURI);\n  }\n  RemoteDirectorGroup rdfGroup=this.getDbClient().queryObject(RemoteDirectorGroup.class,srdfGroupURI);\n  if (null != rdfGroup && !rdfGroup.getInactive()) {\n    rdfGroupCache.put(srdfGroupURI,rdfGroup);\n  }\n  return rdfGroup;\n}\n", "nl": "Return the RemoteDirectorGroup from cache otherwise query from db."}
{"code": "public static int minCut(String s){\n  Set<String> palin=new HashSet<String>();\n  return minCut(s,0,palin);\n}\n", "nl": "Backtracking, generate all cuts"}
{"code": "public ObjectWriter withDateFormat(DateFormat df){\n  SerializationConfig newConfig=_config.withDateFormat(df);\n  if (newConfig == _config) {\n    return this;\n  }\n  return new ObjectWriter(this,newConfig);\n}\n", "nl": "Fluent factory method that will construct a new writer instance that will use specified date format for serializing dates; or if null passed, one that will serialize dates as numeric timestamps."}
{"code": "LockMode(final boolean allowsTouch,final boolean allowsCommands){\n  this.allowsTouch=allowsTouch;\n  this.allowsCommands=allowsCommands;\n}\n", "nl": "Constructs a new LockMode instance."}
{"code": "public boolean match(Element e,String pseudoE){\n  return (e instanceof CSSStylableElement) ? ((CSSStylableElement)e).isPseudoInstanceOf(getValue()) : false;\n}\n", "nl": "Tests whether this selector matches the given element."}
{"code": "RandomAccessFile openInputFileAsZip(String fileName) throws IOException {\n  ZipFile zipFile;\n  try {\n    zipFile=new ZipFile(fileName);\n  }\n catch (  FileNotFoundException fnfe) {\n    System.err.println(\"Unable to open '\" + fileName + \"': \"+ fnfe.getMessage());\n    throw fnfe;\n  }\ncatch (  ZipException ze) {\n    return null;\n  }\n  ZipEntry entry=zipFile.getEntry(CLASSES_DEX);\n  if (entry == null) {\n    System.err.println(\"Unable to find '\" + CLASSES_DEX + \"' in '\"+ fileName+ \"'\");\n    zipFile.close();\n    throw new ZipException();\n  }\n  InputStream zis=zipFile.getInputStream(entry);\n  File tempFile=File.createTempFile(\"dexdeps\",\".dex\");\n  RandomAccessFile raf=new RandomAccessFile(tempFile,\"rw\");\n  tempFile.delete();\n  byte copyBuf[]=new byte[32768];\n  int actual;\n  while (true) {\n    actual=zis.read(copyBuf);\n    if (actual == -1)     break;\n    raf.write(copyBuf,0,actual);\n  }\n  zis.close();\n  raf.seek(0);\n  return raf;\n}\n", "nl": "Tries to open an input file as a Zip archive (jar/apk) with a \"classes.dex\" inside."}
{"code": "public boolean generate(Projection proj){\n  setNeedToRegenerate(true);\n  if (proj == null) {\n    Debug.message(\"omgraphic\",\"OMRect: null projection in generate!\");\n    return false;\n  }\nswitch (renderType) {\ncase RENDERTYPE_XY:\n    setShape(createBoxShape((int)Math.min(x2,x1),(int)Math.min(y2,y1),(int)Math.abs(x2 - x1),(int)Math.abs(y2 - y1)));\n  break;\ncase RENDERTYPE_OFFSET:\nif (!proj.isPlotable(lat1,lon1)) {\n  setNeedToRegenerate(true);\n  return false;\n}\nPoint p1=(Point)proj.forward(lat1,lon1,new Point());\nsetShape(createBoxShape((int)Math.min(p1.x + x1,p1.x + x2),(int)Math.min(p1.y + y1,p1.y + y2),(int)Math.abs(x2 - x1),(int)Math.abs(y2 - y1)));\nbreak;\ncase RENDERTYPE_LATLON:\nArrayList<float[]> rects;\nif (proj instanceof GeoProj) {\nrects=((GeoProj)proj).forwardRect(new LatLonPoint.Double(lat1,lon1),new LatLonPoint.Double(lat2,lon2),lineType,nsegs,!isClear(fillPaint));\n}\n else {\nrects=proj.forwardRect(new Point2D.Double(lon1,lat1),new Point2D.Double(lon2,lat2));\n}\nint size=rects.size();\nGeneralPath projectedShape=null;\nfor (int i=0; i < size; i+=2) {\nGeneralPath gp=createShape(rects.get(i),rects.get(i + 1),true);\nprojectedShape=appendShapeEdge(projectedShape,gp,false);\n}\nsetShape(projectedShape);\nbreak;\ncase RENDERTYPE_UNKNOWN:\nSystem.err.println(\"OMRect.generate(): invalid RenderType\");\nreturn false;\n}\nsetLabelLocation(getShape(),proj);\nsetNeedToRegenerate(false);\nreturn true;\n}\n", "nl": "Prepare the rectangle for rendering."}
{"code": "public void stream(OutputStream os) throws IOException {\n  MessageHeader globals=entries.elementAt(0);\n  if (globals.findValue(\"Signature-Version\") == null) {\n    throw new JarException(\"Signature file requires \" + \"Signature-Version: 1.0 in 1st header\");\n  }\n  PrintStream ps=new PrintStream(os);\n  globals.print(ps);\n  for (int i=1; i < entries.size(); ++i) {\n    MessageHeader mh=entries.elementAt(i);\n    mh.print(ps);\n  }\n}\n", "nl": "Add a signature file at current position in a stream"}
{"code": "public long readDateTimeAsLong(int index){\n  return this.readULong(index) << 32 | this.readULong(index + 4);\n}\n", "nl": "Reads the LONGDATETIME at the given index."}
{"code": "public static Value BagToSet(Value b){\n  FcnRcdValue fcn=FcnRcdValue.convert(b);\n  if (fcn == null) {\n    throw new EvalException(EC.TLC_MODULE_APPLYING_TO_WRONG_VALUE,new String[]{\"BagToSet\",\"a function with a finite domain\",Value.ppr(b.toString())});\n  }\n  return fcn.getDomain();\n}\n", "nl": "// For now, we do not override SubBag. So, We are using the TLA+ definition. public static Value SubBag(Value b) { FcnRcdValue fcn = FcnRcdValue.convert(b); if (fcn == null) { String msg = \"Applying SubBag to the following value, which is\\n\" + \"not a function with a finite domain:\\n\" + Value.ppr(b.toString()); throw new EvalException(msg); } throw new EvalException(\"SubBag is not implemented.\"); }"}
{"code": "public static ProjectActionEvent createProjectClosingEvent(ProjectDescriptor project){\n  return new ProjectActionEvent(project,ProjectAction.CLOSING,false);\n}\n", "nl": "Creates a Project Closing Event."}
{"code": "public int fullyConnectSync(Context srcContext,Handler srcHandler,Handler dstHandler){\n  int status=connectSync(srcContext,srcHandler,dstHandler);\n  if (status == STATUS_SUCCESSFUL) {\n    Message response=sendMessageSynchronously(CMD_CHANNEL_FULL_CONNECTION);\n    status=response.arg1;\n  }\n  return status;\n}\n", "nl": "Fully connect two local Handlers synchronously."}
{"code": "public static boolean hasInterface(String intf,String cls){\n  try {\n    return hasInterface(Class.forName(intf),Class.forName(cls));\n  }\n catch (  Exception e) {\n    return false;\n  }\n}\n", "nl": "Checks whether the given class implements the given interface."}
{"code": "public void removePropertyChangeListener(String propertyName,PropertyChangeListener in_pcl){\n  beanContextChildSupport.removePropertyChangeListener(propertyName,in_pcl);\n}\n", "nl": "Method for BeanContextChild interface. Uses the BeanContextChildSupport to remove a listener to this object's property. You don't need this function for objects that extend java.awt.Component."}
{"code": "private boolean isIgnoreLocallyExistingFiles(){\n  return ignoreLocallyExistingFiles;\n}\n", "nl": "Returns true to indicate that locally existing files are treated as they would not exist. This is a extension to the standard cvs-behaviour!"}
{"code": "private boolean isViewDescendantOf(View child,View parent){\n  if (child == parent) {\n    return true;\n  }\n  final ViewParent theParent=child.getParent();\n  return (theParent instanceof ViewGroup) && isViewDescendantOf((View)theParent,parent);\n}\n", "nl": "Return true if child is an descendant of parent, (or equal to the parent)."}
{"code": "public void add(double value){\n  if (count == 0) {\n    count=1;\n    mean=value;\n    min=value;\n    max=value;\n    if (!isFinite(value)) {\n      sumOfSquaresOfDeltas=NaN;\n    }\n  }\n else {\n    count++;\n    if (isFinite(value) && isFinite(mean)) {\n      double delta=value - mean;\n      mean+=delta / count;\n      sumOfSquaresOfDeltas+=delta * (value - mean);\n    }\n else {\n      mean=calculateNewMeanNonFinite(mean,value);\n      sumOfSquaresOfDeltas=NaN;\n    }\n    min=Math.min(min,value);\n    max=Math.max(max,value);\n  }\n}\n", "nl": "Adds the given value to the dataset."}
{"code": "private void init(Context context,RuqusTheme theme,String currClassName){\n  this.currClassName=currClassName;\n  inflate(context,R.layout.sort_field_view,this);\n  setOrientation(VERTICAL);\n  label=(TextView)findViewById(R.id.sort_field_label);\n  sortFieldChooser=(Spinner)findViewById(R.id.sort_field);\n  removeButton=(ImageButton)findViewById(R.id.remove_field);\n  sortDirRg=(RadioGroup)findViewById(R.id.rg_sort_dir);\n  ascRb=(RadioButton)findViewById(R.id.asc);\n  descRb=(RadioButton)findViewById(R.id.desc);\n  setTheme(theme);\n  sortFieldChooser.setOnTouchListener(sortFieldChooserListener);\n  sortFieldChooser.setOnItemSelectedListener(sortFieldChooserListener);\n}\n", "nl": "Initialize our view."}
{"code": "protected Future<Void> closeNoThrow(){\n  Promise<Void> closeFuture;\nsynchronized (this) {\n    if (null != closePromise) {\n      return closePromise;\n    }\n    closeFuture=closePromise=new Promise<Void>();\n  }\n  cancelTruncation();\n  Utils.closeSequence(bkDistributedLogManager.getScheduler(),true,getCachedLogWriter(),getAllocatedLogWriter(),getCachedWriteHandler()).proxyTo(closeFuture);\n  return closeFuture;\n}\n", "nl": "Close the writer and release all the underlying resources"}
{"code": "public Boolean isValidating(){\n  return validating;\n}\n", "nl": "Gets the value of the validating property."}
{"code": "private String scanPlainSpaces(){\n  int length=0;\n  while (reader.peek(length) == ' ' || reader.peek(length) == '\\t') {\n    length++;\n  }\n  String whitespaces=reader.prefixForward(length);\n  String lineBreak=scanLineBreak();\n  if (lineBreak.length() != 0) {\n    this.allowSimpleKey=true;\n    String prefix=reader.prefix(3);\n    if (\"---\".equals(prefix) || \"...\".equals(prefix) && Constant.NULL_BL_T_LINEBR.has(reader.peek(3))) {\n      return \"\";\n    }\n    StringBuilder breaks=new StringBuilder();\n    while (true) {\n      if (reader.peek() == ' ') {\n        reader.forward();\n      }\n else {\n        String lb=scanLineBreak();\n        if (lb.length() != 0) {\n          breaks.append(lb);\n          prefix=reader.prefix(3);\n          if (\"---\".equals(prefix) || \"...\".equals(prefix) && Constant.NULL_BL_T_LINEBR.has(reader.peek(3))) {\n            return \"\";\n          }\n        }\n else {\n          break;\n        }\n      }\n    }\n    if (!\"\\n\".equals(lineBreak)) {\n      return lineBreak + breaks;\n    }\n else     if (breaks.length() == 0) {\n      return \" \";\n    }\n    return breaks.toString();\n  }\n  return whitespaces;\n}\n", "nl": "See the specification for details. SnakeYAML and libyaml allow tabs inside plain scalar"}
{"code": "public static void w(String tag,String s,Throwable e){\n  if (LOG.WARN >= LOGLEVEL)   Log.w(tag,s,e);\n}\n", "nl": "Warning log message."}
{"code": "public static double mean(double[] vector){\n  double sum=0;\n  if (vector.length == 0) {\n    return 0;\n  }\n  for (int i=0; i < vector.length; i++) {\n    sum+=vector[i];\n  }\n  return sum / (double)vector.length;\n}\n", "nl": "Computes the mean for an array of doubles."}
{"code": "protected byte[] toJsonBytes(final Object object) throws Exception {\n  ObjectMapper mapper=new ObjectMapper();\n  mapper.setSerializationInclusion(JsonSerialize.Inclusion.NON_NULL);\n  return mapper.writeValueAsBytes(object);\n}\n", "nl": "Map object to JSON bytes"}
{"code": "public void shuffleInventory(@Nonnull IInventory inv,@Nonnull Random random){\n  final List<ItemStack> list=getInventoryList(inv);\n  Collections.shuffle(list,random);\n  for (int i=0; i < inv.getSizeInventory(); ++i) {\n    inv.setInventorySlotContents(i,list.get(i));\n  }\n}\n", "nl": "Shuffles all items in the inventory"}
{"code": "public QueueCursor(int capacity){\n  this(capacity,false);\n}\n", "nl": "Creates an <tt>QueueCursor</tt> with the given (fixed) capacity and default access policy."}
{"code": "public void destroy(DistributedRegion r){\n}\n", "nl": "Blows away all the data in this object."}
{"code": "public Process executeAsync(final CommandLine command,ExecuteResultHandler handler) throws IOException {\n  return executeAsync(command,null,handler);\n}\n", "nl": "Methods for starting asynchronous execution. The child process inherits all environment variables of the parent process. Result provided to callback handler."}
{"code": "public static void destroy(){\n  try {\n    Region region1=cache.getRegion(Region.SEPARATOR + REGION_NAME);\n    region1.localDestroy(\"key-1\");\n  }\n catch (  Exception e) {\n    e.printStackTrace();\n    fail(\"test failed due to exception in destroy \");\n  }\n}\n", "nl": "destroy key-1"}
{"code": "public boolean isSelected(){\n  return this.selected;\n}\n", "nl": "Check if item is selected"}
{"code": "public String(String string){\n  value=string.value;\n  offset=string.offset;\n  count=string.count;\n}\n", "nl": "Creates a string that is a copy of another string"}
{"code": "private void needNewBuffer(int newSize){\n  int delta=newSize - size;\n  int newBufferSize=Math.max(minChunkLen,delta);\n  currentBufferIndex++;\n  currentBuffer=new int[newBufferSize];\n  offset=0;\n  if (currentBufferIndex >= buffers.length) {\n    int newLen=buffers.length << 1;\n    int[][] newBuffers=new int[newLen][];\n    System.arraycopy(buffers,0,newBuffers,0,buffers.length);\n    buffers=newBuffers;\n  }\n  buffers[currentBufferIndex]=currentBuffer;\n  buffersCount++;\n}\n", "nl": "Prepares next chunk to match new size. The minimal length of new chunk is <code>minChunkLen</code>."}
{"code": "public static TestResult execJavac(String toCompile,File dir,String jflexTestVersion){\n  Project p=new Project();\n  Javac javac=new Javac();\n  Path path=new Path(p,dir.toString());\n  javac.setProject(p);\n  javac.setSrcdir(path);\n  javac.setDestdir(dir);\n  javac.setTarget(javaVersion);\n  javac.setSource(javaVersion);\n  javac.setSourcepath(new Path(p,\"\"));\n  javac.setIncludes(toCompile);\n  Path classPath=javac.createClasspath();\n  classPath.setPath(System.getProperty(\"user.home\") + \"/.m2/repository/de/jflex/jflex/\" + jflexTestVersion+ \"/jflex-\"+ jflexTestVersion+ \".jar\");\n  ByteArrayOutputStream out=new ByteArrayOutputStream();\n  PrintStream outSafe=System.err;\n  System.setErr(new PrintStream(out));\n  try {\n    javac.execute();\n    return new TestResult(out.toString(),true);\n  }\n catch (  BuildException e) {\n    return new TestResult(e + System.getProperty(\"line.separator\") + out.toString(),false);\n  }\n finally {\n    System.setErr(outSafe);\n  }\n}\n", "nl": "Call javac on toCompile in input dir. If toCompile is null,  all *.java files below dir will be compiled."}
{"code": "private void cloneProperties(BurpCertificate certificate,BurpCertificateBuilder burpCertificateBuilder){\n  burpCertificateBuilder.setVersion(certificate.getVersionNumber());\n  burpCertificateBuilder.setSerial(certificate.getSerialNumberBigInteger());\n  if (certificate.getPublicKeyAlgorithm().equals(\"RSA\")) {\n    burpCertificateBuilder.setSignatureAlgorithm(certificate.getSignatureAlgorithm());\n  }\n else {\n    burpCertificateBuilder.setSignatureAlgorithm(\"SHA256withRSA\");\n  }\n  burpCertificateBuilder.setIssuer(certificate.getIssuer());\n  burpCertificateBuilder.setNotAfter(certificate.getNotAfter());\n  burpCertificateBuilder.setNotBefore(certificate.getNotBefore());\n  burpCertificateBuilder.setKeySize(certificate.getKeySize());\n  for (  BurpCertificateExtension extension : certificate.getAllExtensions()) {\n    burpCertificateBuilder.addExtension(extension);\n  }\n}\n", "nl": "Copy all X.509v3 general information and all extensions 1:1 from one source certificat to one destination certificate."}
{"code": "protected void emit_PropertyMethodDeclaration_SemicolonKeyword_1_q(EObject semanticObject,ISynNavigable transition,List<INode> nodes){\n  acceptNodes(transition,nodes);\n}\n", "nl": "Ambiguous syntax: ';'? This ambiguous syntax occurs at: body=Block (ambiguity) (rule end) declaredName=LiteralOrComputedPropertyName '(' ')' (ambiguity) (rule end) fpars+=FormalParameter ')' (ambiguity) (rule end)"}
{"code": "public void runTest() throws Throwable {\n  Document doc;\n  Element rootNode;\n  Node newChild;\n  NodeList elementList;\n  Node oldChild;\n  Node replacedChild;\n  doc=(Document)load(\"hc_staff\",true);\n  newChild=doc.createAttribute(\"lang\");\n  elementList=doc.getElementsByTagName(\"p\");\n  oldChild=elementList.item(1);\n  rootNode=(Element)oldChild.getParentNode();\n{\n    boolean success=false;\n    try {\n      replacedChild=rootNode.replaceChild(newChild,oldChild);\n    }\n catch (    DOMException ex) {\n      success=(ex.code == DOMException.HIERARCHY_REQUEST_ERR);\n    }\n    assertTrue(\"throw_HIERARCHY_REQUEST_ERR\",success);\n  }\n}\n", "nl": "Runs the test case."}
{"code": "public void preComputeBestReplicaMapping(){\n  Map<String,Map<String,Map<String,String>>> collectionToShardToCoreMapping=getZkClusterData().getCollectionToShardToCoreMapping();\n  for (  String collection : collectionNames) {\n    Map<String,Map<String,String>> shardToCoreMapping=collectionToShardToCoreMapping.get(collection);\n    for (    String shard : shardToCoreMapping.keySet()) {\n      Map<String,String> coreToNodeMap=shardToCoreMapping.get(shard);\n      for (      String core : coreToNodeMap.keySet()) {\n        String currentCore=core;\n        String node=coreToNodeMap.get(core);\n        SolrCore currentReplica=new SolrCore(node,currentCore);\n        try {\n          currentReplica.loadStatus();\n          fillUpAllCoresForShard(currentReplica,coreToNodeMap);\n          break;\n        }\n catch (        Exception e) {\n          logger.info(ExceptionUtils.getFullStackTrace(e));\n          continue;\n        }\n      }\n      shardToBestReplicaMapping.put(shard,coreToBestReplicaMappingByHealth);\n    }\n  }\n}\n", "nl": "For all the collections in zookeeper, compute the best replica for every shard for every collection. Doing this computation at bootup significantly reduces the computation done during streaming."}
{"code": "private void statInit(){\n  lDocumentNo.setLabelFor(fDocumentNo);\n  fDocumentNo.setBackground(AdempierePLAF.getInfoBackground());\n  fDocumentNo.addActionListener(this);\n  lDescription.setLabelFor(fDescription);\n  fDescription.setBackground(AdempierePLAF.getInfoBackground());\n  fDescription.addActionListener(this);\n  lPOReference.setLabelFor(fPOReference);\n  fPOReference.setBackground(AdempierePLAF.getInfoBackground());\n  fPOReference.addActionListener(this);\n  fIsSOTrx.setSelected(!\"N\".equals(Env.getContext(Env.getCtx(),p_WindowNo,\"IsSOTrx\")));\n  fIsSOTrx.addActionListener(this);\n  fBPartner_ID=new VLookup(\"C_BPartner_ID\",false,false,true,MLookupFactory.get(Env.getCtx(),p_WindowNo,0,MColumn.getColumn_ID(MInOut.Table_Name,MInOut.COLUMNNAME_C_BPartner_ID),DisplayType.Search));\n  lBPartner_ID.setLabelFor(fBPartner_ID);\n  fBPartner_ID.setBackground(AdempierePLAF.getInfoBackground());\n  fBPartner_ID.addActionListener(this);\n  fShipper_ID=new VLookup(\"M_Shipper_ID\",false,false,true,MLookupFactory.get(Env.getCtx(),p_WindowNo,0,MColumn.getColumn_ID(MInOut.Table_Name,MInOut.COLUMNNAME_M_Shipper_ID),DisplayType.TableDir));\n  lShipper_ID.setLabelFor(fShipper_ID);\n  fShipper_ID.setBackground(AdempierePLAF.getInfoBackground());\n  fShipper_ID.addActionListener(this);\n  lDateFrom.setLabelFor(fDateFrom);\n  fDateFrom.setBackground(AdempierePLAF.getInfoBackground());\n  fDateFrom.setToolTipText(Msg.translate(Env.getCtx(),\"DateFrom\"));\n  fDateFrom.addActionListener(this);\n  lDateTo.setLabelFor(fDateTo);\n  fDateTo.setBackground(AdempierePLAF.getInfoBackground());\n  fDateTo.setToolTipText(Msg.translate(Env.getCtx(),\"DateTo\"));\n  fDateTo.addActionListener(this);\n  CPanel datePanel=new CPanel();\n  datePanel.setLayout(new ALayout(0,0,true));\n  datePanel.add(fDateFrom,new ALayoutConstraint(0,0));\n  datePanel.add(lDateTo,null);\n  datePanel.add(fDateTo,null);\n  p_criteriaGrid.add(lDocumentNo,new ALayoutConstraint(0,0));\n  p_criteriaGrid.add(fDocumentNo,null);\n  p_criteriaGrid.add(lBPartner_ID,null);\n  p_criteriaGrid.add(fBPartner_ID,null);\n  p_criteriaGrid.add(fIsSOTrx,new ALayoutConstraint(0,5));\n  p_criteriaGrid.add(lDescription,new ALayoutConstraint(1,0));\n  p_criteriaGrid.add(fDescription,null);\n  p_criteriaGrid.add(lDateFrom,null);\n  p_criteriaGrid.add(datePanel,null);\n  p_criteriaGrid.add(lPOReference,new ALayoutConstraint(2,0));\n  p_criteriaGrid.add(fPOReference,null);\n  p_criteriaGrid.add(lShipper_ID,null);\n  p_criteriaGrid.add(fShipper_ID,null);\n}\n", "nl": "Static Setup - add fields to parameterPanel"}
{"code": "@Override public boolean check(final CertificateToken certificateToken){\n  final boolean keyUsage=certificateToken.checkKeyUsage(bit);\n  return keyUsage == value;\n}\n", "nl": "Checks the condition for the given certificate."}
{"code": "public static boolean isValidFolderPath(Path path){\n  if (path == null) {\n    return false;\n  }\n  File f=path.toFile();\n  return path.toString().isEmpty() || (f.isDirectory() && f.canWrite());\n}\n", "nl": "Checks is the parameter path a valid for saving fixed file"}
{"code": "public float[][] extract(int maxFeatureValue,int[] distanceSet,int[][] img){\n  int[] histogram=new int[maxFeatureValue];\n  final int W=img.length;\n  final int H=img[0].length;\n  for (int x=0; x < W; x++) {\n    for (int y=0; y < H; y++) {\n      histogram[img[x][y]]++;\n    }\n  }\n  float[][] correlogram=new float[maxFeatureValue][distanceSet.length];\n  int[] tmpCorrelogram=new int[distanceSet.length];\n  for (int x=0; x < W; x++) {\n    for (int y=0; y < H; y++) {\n      int color=img[x][y];\n      getNumPixelsInNeighbourhood(x,y,img,tmpCorrelogram,maxFeatureValue,distanceSet);\n      for (int i=0; i < distanceSet.length; i++) {\n        correlogram[color][i]+=tmpCorrelogram[i];\n      }\n    }\n  }\n  float[] max=new float[distanceSet.length];\n  for (int c=0; c < maxFeatureValue; c++) {\n    for (int i=0; i < distanceSet.length; i++) {\n      max[i]=Math.max(correlogram[c][i],max[i]);\n    }\n  }\n  for (int c=0; c < maxFeatureValue; c++) {\n    for (int i=0; i < distanceSet.length; i++) {\n      correlogram[c][i]=correlogram[c][i] / max[i];\n    }\n  }\n  return correlogram;\n}\n", "nl": "extract extracts an auto-correlogram from an Image. This method create a cummulated auto-correlogram over different distances instead of standard method. Also, uses a different normalization method"}
{"code": "SegmentTreeNode<?> computeRightChild(SegmentTreeNode<?> node){\n  if (node.right - node.left > 1) {\n    return constructor.construct((node.left + node.right) / 2,node.right);\n  }\n  return null;\n}\n", "nl": "Compute the right child node, if it exists"}
{"code": "public static boolean isValidIPAddress(String address){\n  if (address == null || address.length() == 0) {\n    return false;\n  }\n  boolean ipv6Expected=false;\n  if (address.charAt(0) == '[') {\n    if (address.length() > 2 && address.charAt(address.length() - 1) == ']') {\n      address=address.substring(1,address.length() - 1);\n      ipv6Expected=true;\n    }\n else {\n      return false;\n    }\n  }\n  if (Character.digit(address.charAt(0),16) != -1 || (address.charAt(0) == ':')) {\n    byte[] addr=null;\n    addr=strToIPv4(address);\n    if (addr == null) {\n      addr=strToIPv6(address);\n    }\n else     if (ipv6Expected) {\n      return false;\n    }\n    if (addr != null) {\n      return true;\n    }\n  }\n  return false;\n}\n", "nl": "Checks whether <tt>address</tt> is a valid IP address string."}
{"code": "private void loadVerticesAndRelatives(){\n  List<CnATreeElement> elementList=new LinkedList<CnATreeElement>();\n  for (  IGraphElementLoader loader : getLoaderList()) {\n    loader.setCnaTreeElementDao(getCnaTreeElementDao());\n    elementList.addAll(loader.loadElements());\n  }\n  for (  CnATreeElement element : elementList) {\n    graph.addVertex(element);\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Vertex added: \" + element.getTitle());\n    }\n    uuidMap.put(element.getUuid(),element);\n  }\n  for (  CnATreeElement parent : elementList) {\n    Set<CnATreeElement> children=parent.getChildren();\n    for (    CnATreeElement child : children) {\n      createParentChildEdge(parent,child);\n    }\n  }\n}\n", "nl": "Loads all vertices and adds them to the graph. An edge for each children is added if the child is part of the graph."}
{"code": "private void initializeLiveAttributes(){\n  transform=createLiveAnimatedTransformList(null,SVG_TRANSFORM_ATTRIBUTE,\"\");\n  externalResourcesRequired=createLiveAnimatedBoolean(null,SVG_EXTERNAL_RESOURCES_REQUIRED_ATTRIBUTE,false);\n}\n", "nl": "Initializes the live attribute values of this element."}
{"code": "public void putParcelable(String key,Parcelable value){\n  unparcel();\n  mMap.put(key,value);\n  mFdsKnown=false;\n}\n", "nl": "Inserts a Parcelable value into the mapping of this Bundle, replacing any existing value for the given key.  Either key or value may be null."}
{"code": "public static <T>Collection<T> flatten(Iterable<T> self,Closure<? extends T> flattenUsing){\n  return flatten(self,createSimilarCollection(self),flattenUsing);\n}\n", "nl": "Flatten an Iterable.  This Iterable and any nested arrays or collections have their contents (recursively) added to the new collection. For any non-Array, non-Collection object which represents some sort of collective type, the supplied closure should yield the contained items; otherwise, the closure should just return any element which corresponds to a leaf."}
{"code": "public double semiDeviation(){\n  return Math.sqrt(semiVariance());\n}\n", "nl": "returns the semi deviation, defined as the square root of the semi variance."}
{"code": "public Object runSafely(Catbert.FastStack stack) throws Exception {\n  String val=getString(stack);\n  Sage.put(getString(stack),val);\n  return null;\n}\n", "nl": "Sets the property with the specified name to the specified value. If this is called from a client instance then it will use the properties on the server system for this call and the change will be made on the server system."}
{"code": "protected Preference createUserDictionaryPreference(String locale,Activity activity){\n  final Preference newPref=new Preference(getActivity());\n  final Intent intent=new Intent(USER_DICTIONARY_SETTINGS_INTENT_ACTION);\n  if (null == locale) {\n    newPref.setTitle(Locale.getDefault().getDisplayName());\n  }\n else {\n    if (\"\".equals(locale))     newPref.setTitle(getString(R.string.user_dict_settings_all_languages));\n else     newPref.setTitle(Utils.createLocaleFromString(locale).getDisplayName());\n    intent.putExtra(\"locale\",locale);\n    newPref.getExtras().putString(\"locale\",locale);\n  }\n  newPref.setIntent(intent);\n  newPref.setFragment(com.android.settings.UserDictionarySettings.class.getName());\n  return newPref;\n}\n", "nl": "Create a single User Dictionary Preference object, with its parameters set."}
{"code": "public static <T>T withPrintWriter(Path self,@ClosureParams(value=SimpleType.class,options=\"java.io.PrintWriter\") Closure<T> closure) throws IOException {\n  return IOGroovyMethods.withWriter(newPrintWriter(self),closure);\n}\n", "nl": "Create a new PrintWriter for this file which is then passed it into the given closure.  This method ensures its the writer is closed after the closure returns."}
{"code": "public void testBug77649() throws Exception {\n  Properties props=getPropertiesFromTestsuiteUrl();\n  String host=props.getProperty(NonRegisteringDriver.HOST_PROPERTY_KEY);\n  String port=props.getProperty(NonRegisteringDriver.PORT_PROPERTY_KEY);\n  String[] hosts=new String[]{host,\"address\",\"address.somewhere\",\"addressing\",\"addressing.somewhere\"};\n  UnreliableSocketFactory.flushAllStaticData();\n  for (int i=1; i < hosts.length; i++) {\n    UnreliableSocketFactory.mapHost(hosts[i],host);\n  }\n  props=getHostFreePropertiesFromTestsuiteUrl();\n  props.setProperty(\"socketFactory\",UnreliableSocketFactory.class.getName());\n  for (  String h : hosts) {\n    getConnectionWithProps(String.format(\"jdbc:mysql://%s:%s\",h,port),props).close();\n    getConnectionWithProps(String.format(\"jdbc:mysql://address=(protocol=tcp)(host=%s)(port=%s)\",h,port),props).close();\n  }\n}\n", "nl": "Tests fix for Bug#77649 - URL start with word \"address\",JDBC can't parse the \"host:port\" Correctly."}
{"code": "public final Iterator<PluginPatternMatcher> pathsIterator(){\n  return mDataPaths != null ? mDataPaths.iterator() : null;\n}\n", "nl": "Return an iterator over the filter's data paths."}
{"code": "private void checkInMoving(float x,float y){\n  final int xDiff=(int)Math.abs(x - lastMotionX);\n  final int yDiff=(int)Math.abs(y - lastMotionY);\n  final int touchSlop=this.touchSlop;\n  boolean xMoved=xDiff > touchSlop;\n  boolean yMoved=yDiff > touchSlop;\n  if (xMoved) {\n    touchState=TOUCH_STATE_SCROLLING_X;\n    lastMotionX=x;\n    lastMotionY=y;\n  }\n  if (yMoved) {\n    touchState=TOUCH_STATE_SCROLLING_Y;\n    lastMotionX=x;\n    lastMotionY=y;\n  }\n}\n", "nl": "Check if the user is moving the cell"}
{"code": "public final boolean checkInstance(Instance instance){\n  if (instance.numAttributes() != numAttributes()) {\n    return false;\n  }\n  for (int i=0; i < numAttributes(); i++) {\n    if (instance.isMissing(i)) {\n      continue;\n    }\n else     if (attribute(i).isNominal() || attribute(i).isString()) {\n      if (!(Utils.eq(instance.value(i),(double)(int)instance.value(i)))) {\n        return false;\n      }\n else       if (Utils.sm(instance.value(i),0) || Utils.gr(instance.value(i),attribute(i).numValues())) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n", "nl": "Checks if the given instance is compatible with this dataset. Only looks at the size of the instance and the ranges of the values for  nominal and string attributes."}
{"code": "private static byte[] concatBytes(byte[] array1,byte[] array2){\n  byte[] cBytes=new byte[array1.length + array2.length];\n  try {\n    System.arraycopy(array1,0,cBytes,0,array1.length);\n    System.arraycopy(array2,0,cBytes,array1.length,array2.length);\n  }\n catch (  Exception e) {\n    throw new FacesException(e);\n  }\n  return cBytes;\n}\n", "nl": "This method concatenates two byte arrays"}
{"code": "void layout(int delta,boolean animate){\n  if (mDataChanged) {\n    handleDataChanged();\n  }\n  if (getCount() == 0) {\n    resetList();\n    return;\n  }\n  if (mNextSelectedPosition >= 0) {\n    setSelectedPositionInt(mNextSelectedPosition);\n  }\n  recycleAllViews();\n  detachAllViewsFromParent();\n  int count=getAdapter().getCount();\n  float angleUnit=360.0f / count;\n  float angleOffset=mSelectedPosition * angleUnit;\n  for (int i=0; i < getAdapter().getCount(); i++) {\n    float angle=angleUnit * i - angleOffset;\n    if (angle < 0.0f)     angle=360.0f + angle;\n    makeAndAddView(i,angle);\n  }\n  mRecycler.clear();\n  invalidate();\n  setNextSelectedPositionInt(mSelectedPosition);\n  checkSelectionChanged();\n  mNeedSync=false;\n  updateSelectedItemMetadata();\n}\n", "nl": "Setting up images."}
{"code": "private void updateMenuItems(boolean isGpsStarted,boolean isRecording){\n  boolean hasTrack=listView != null && listView.getCount() != 0;\n  if (startGpsMenuItem != null) {\n    startGpsMenuItem.setVisible(!isRecording);\n    if (!isRecording) {\n      startGpsMenuItem.setTitle(isGpsStarted ? R.string.menu_stop_gps : R.string.menu_start_gps);\n      startGpsMenuItem.setIcon(isGpsStarted ? R.drawable.ic_menu_stop_gps : R.drawable.ic_menu_start_gps);\n      TrackIconUtils.setMenuIconColor(startGpsMenuItem);\n    }\n  }\n  if (playMultipleItem != null) {\n    playMultipleItem.setVisible(hasTrack);\n  }\n  if (syncNowMenuItem != null) {\n    syncNowMenuItem.setTitle(driveSync ? R.string.menu_sync_now : R.string.menu_sync_drive);\n  }\n  if (aggregatedStatisticsMenuItem != null) {\n    aggregatedStatisticsMenuItem.setVisible(hasTrack);\n  }\n  if (exportAllMenuItem != null) {\n    exportAllMenuItem.setVisible(hasTrack && !isRecording);\n  }\n  if (importAllMenuItem != null) {\n    importAllMenuItem.setVisible(!isRecording);\n  }\n  if (deleteAllMenuItem != null) {\n    deleteAllMenuItem.setVisible(hasTrack && !isRecording);\n  }\n}\n", "nl": "Updates the menu items."}
{"code": "public boolean isDuplicateSupported(){\n  return duplicateSupported;\n}\n", "nl": "Indicates whether this connection request supports duplicate entries in the request queue"}
{"code": "public void onStart(){\n}\n", "nl": "Called when the animation starts."}
{"code": "public static int[][] loadPNMFile(InputStream str) throws IOException {\n  BufferedInputStream stream=new BufferedInputStream(str);\n  String type=tokenizeString(stream);\n  if (type.equals(\"P1\"))   return loadPlainPBM(stream);\n else   if (type.equals(\"P2\"))   return loadPlainPGM(stream);\n else   if (type.equals(\"P4\"))   return loadRawPBM(stream);\n else   if (type.equals(\"P5\"))   return loadRawPGM(stream);\n else   throw new IOException(\"Not a viable PBM or PGM stream\");\n}\n", "nl": "Loads plain or raw PGM files or plain or raw PBM files and return the result as an int[][]. The Y dimension is not flipped."}
{"code": "public BiCorpus alignedFromFiles(String f) throws IOException {\n  return new BiCorpus(fpath + f + extf,epath + f + exte,apath + f + exta);\n}\n", "nl": "Generate aligned BiCorpus."}
{"code": "public LognormalDistr(double shape,double scale){\n  numGen=new LogNormalDistribution(scale,shape);\n}\n", "nl": "Instantiates a new Log-normal pseudo random number generator."}
{"code": "private static String contentLengthHeader(final long length){\n  return String.format(\"Content-Length: %d\",length);\n}\n", "nl": "Format Content-Length header."}
{"code": "@Bean @ConditionalOnMissingBean public AmqpSenderService amqpSenderServiceBean(){\n  return new DefaultAmqpSenderService(rabbitTemplate());\n}\n", "nl": "Create default amqp sender service bean."}
{"code": "@Override protected void initialize(){\n  super.initialize();\n  m_Processor=new MarkdownProcessor();\n  m_Markdown=\"\";\n}\n", "nl": "Initializes the members."}
{"code": "public void upperBound(byte[] key) throws IOException {\n  upperBound(key,0,key.length);\n}\n", "nl": "Move the cursor to the first entry whose key is strictly greater than the input key. Synonymous to upperBound(key, 0, key.length). The entry returned by the previous entry() call will be invalid."}
{"code": "public static String replaceLast(String s,char sub,char with){\n  int index=s.lastIndexOf(sub);\n  if (index == -1) {\n    return s;\n  }\n  char[] str=s.toCharArray();\n  str[index]=with;\n  return new String(str);\n}\n", "nl": "Replaces the very last occurrence of a character in a string."}
{"code": "public static void main(String[] args){\n  Thrust simulation=new Thrust();\n  simulation.run();\n}\n", "nl": "Entry point for the example application."}
{"code": "public static <T>T checkNotNull(T reference,@Nullable String errorMessageTemplate,@Nullable Object... errorMessageArgs){\n  if (reference == null) {\n    throw new NullPointerException(format(errorMessageTemplate,errorMessageArgs));\n  }\n  return reference;\n}\n", "nl": "Ensures that an object reference passed as a parameter to the calling method is not null."}
{"code": "public boolean insert(String name,RegExp definition){\n  if (Options.DEBUG)   Out.debug(\"inserting macro \" + name + \" with definition :\"+ Out.NL+ definition);\n  used.put(name,Boolean.FALSE);\n  return macros.put(name,definition) == null;\n}\n", "nl": "Stores a new macro and its definition."}
{"code": "public boolean add(Object o){\n  ensureCapacity(size + 1);\n  elementData[size++]=o;\n  return true;\n}\n", "nl": "Appends the specified element to the end of this list."}
{"code": "public InvocationTargetException(Throwable target,String s){\n  super(s,null);\n  this.target=target;\n}\n", "nl": "Constructs a InvocationTargetException with a target exception and a detail message."}
{"code": "public boolean isExternalSkin(){\n  return !isDefaultSkin && mResources != null;\n}\n", "nl": "whether the skin being used is from external .skin file"}
{"code": "private void updateActions(){\n  actions.removeAll();\n  final ActionGroup mainActionGroup=(ActionGroup)actionManager.getAction(getGroupMenu());\n  if (mainActionGroup == null) {\n    return;\n  }\n  final Action[] children=mainActionGroup.getChildren(null);\n  for (  final Action action : children) {\n    final Presentation presentation=presentationFactory.getPresentation(action);\n    final ActionEvent e=new ActionEvent(ActionPlaces.MAIN_CONTEXT_MENU,presentation,actionManager,0);\n    action.update(e);\n    if (presentation.isVisible()) {\n      actions.add(action);\n    }\n  }\n}\n", "nl": "Updates the list of visible actions."}
{"code": "private void showFeedback(String message){\n  if (myHost != null) {\n    myHost.showFeedback(message);\n  }\n else {\n    System.out.println(message);\n  }\n}\n", "nl": "Used to communicate feedback pop-up messages between a plugin tool and the main Whitebox user-interface."}
{"code": "TechCategory fallthrough(){\nswitch (this) {\ncase OMNI_AERO:\n    return OMNI;\ncase CLAN_AERO:\ncase CLAN_VEE:\n  return CLAN;\ncase IS_ADVANCED_AERO:\ncase IS_ADVANCED_VEE:\nreturn IS_ADVANCED;\ndefault :\nreturn null;\n}\n}\n", "nl": "If no value is provided for ASFs or Vees, use the base value."}
{"code": "static void svd_dscal(int n,double da,double[] dx,int incx){\n  if (n <= 0 || incx == 0)   return;\n  int ix=(incx < 0) ? n - 1 : 0;\n  for (int i=0; i < n; i++) {\n    dx[ix]*=da;\n    ix+=incx;\n  }\n  return;\n}\n", "nl": "Function scales a vector by a constant. * Based on Fortran-77 routine from Linpack by J. Dongarra"}
{"code": "public CampoFechaVO insertValue(final CampoFechaVO value){\n  try {\n    DbConnection conn=getConnection();\n    DbInsertFns.insert(conn,TABLE_NAME,DbUtil.getColumnNames(COL_DEFS),new SigiaDbInputRecord(COL_DEFS,value));\n    return value;\n  }\n catch (  Exception e) {\n    logger.error(\"Error insertando campo de tipo fecha para el descriptor \" + value.getIdObjeto(),e);\n    throw new DBException(\"insertando campo de tipo fecha\",e);\n  }\n}\n", "nl": "Inserta un valor de tipo fecha."}
{"code": "private synchronized void closeActiveFile(){\n  StringWriterFile activeFile=this.activeFile;\n  try {\n    this.activeFile=null;\n    if (activeFile != null) {\n      activeFile.close();\n      getPolicy().closeActiveFile(activeFile.path());\n      activeFile=null;\n    }\n  }\n catch (  IOException e) {\n    trace.error(\"error closing active file '{}'\",activeFile.path(),e);\n  }\n}\n", "nl": "close, finalize, and apply retention policy"}
{"code": "public void testWARTypeEquality(){\n  WAR war1=new WAR(\"/some/path/to/file.war\");\n  WAR war2=new WAR(\"/otherfile.war\");\n  assertEquals(war1.getType(),war2.getType());\n}\n", "nl": "Test equality between WAR deployables."}
{"code": "public static Vector readSignatureAlgorithmsExtension(byte[] extensionData) throws IOException {\n  if (extensionData == null) {\n    throw new IllegalArgumentException(\"'extensionData' cannot be null\");\n  }\n  ByteArrayInputStream buf=new ByteArrayInputStream(extensionData);\n  Vector supported_signature_algorithms=parseSupportedSignatureAlgorithms(false,buf);\n  TlsProtocol.assertEmpty(buf);\n  return supported_signature_algorithms;\n}\n", "nl": "Read 'signature_algorithms' extension data."}
{"code": "public void updateNCharacterStream(int columnIndex,java.io.Reader x,long length) throws SQLException {\n  throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(\"jdbcrowsetimpl.featnotsupp\").toString());\n}\n", "nl": "Updates the designated column with a character stream value, which will have the specified number of bytes. The driver does the necessary conversion from Java character format to the national character set in the database. It is intended for use when updating NCHAR,NVARCHAR and LONGNVARCHAR columns. The updater methods are used to update column values in the current row or the insert row. The updater methods do not update the underlying database; instead the updateRow or insertRow methods are called to update the database."}
{"code": "public boolean isModified(){\n  return isCustom() && !isUserAdded();\n}\n", "nl": "Returns whether the receiver represents a modified template, i.e. a contributed template that has been changed."}
{"code": "public String toString(){\n  return this.getClass().getName() + \"(\" + my_k+ \")\";\n}\n", "nl": "Returns a String representation of the receiver."}
{"code": "private static PostingsEnum termDocs(IndexReader reader,Term term) throws IOException {\n  return MultiFields.getTermDocsEnum(reader,MultiFields.getLiveDocs(reader),term.field(),term.bytes());\n}\n", "nl": "NB: this is a convenient but very slow way of getting termDocs. It is sufficient for testing purposes."}
{"code": "public boolean isSubregion(){\n  return subregion;\n}\n", "nl": "Returns true if the Region is a subregion of a Component, otherwise false. For example, <code>Region.BUTTON</code> corresponds do a <code>Component</code> so that <code>Region.BUTTON.isSubregion()</code> returns false."}
{"code": "public static void encodeToFile(byte[] dataToEncode,String filename) throws java.io.IOException {\n  if (dataToEncode == null) {\n    throw new NullPointerException(\"Data to encode was null.\");\n  }\n  Base64.OutputStream bos=null;\n  try {\n    bos=new Base64.OutputStream(new java.io.FileOutputStream(filename),Base64.ENCODE);\n    bos.write(dataToEncode);\n  }\n catch (  java.io.IOException e) {\n    throw e;\n  }\n finally {\n    try {\n      bos.close();\n    }\n catch (    Exception e) {\n    }\n  }\n}\n", "nl": "Convenience method for encoding data to a file. <p>As of v 2.3, if there is a error, the method will throw an java.io.IOException. <b>This is new to v2.3!</b> In earlier versions, it just returned false, but in retrospect that's a pretty poor way to handle it.</p>"}
{"code": "public synchronized void addDataStatusListener(DataStatusListener l){\n  m_mTab.addDataStatusListener(l);\n}\n", "nl": "Add Data Status Listener - pass on to MTab"}
{"code": "protected void addField(DurationFieldType field,int value){\n  addFieldInto(iValues,field,value);\n}\n", "nl": "Adds the value of a field in this period."}
{"code": "@Override public int perimeter(int size){\n  size=size / 2;\n  int retval=sw.perimeter(size);\n  retval+=se.perimeter(size);\n  retval+=ne.perimeter(size);\n  retval+=nw.perimeter(size);\n  return retval;\n}\n", "nl": "Compute the perimeter for a grey node using Samet's algorithm."}
{"code": "public BigdataStatementIterator addedIterator(){\n  final IChunkedOrderedIterator<ISPO> src=new ChunkedWrappedIterator<ISPO>(added.iterator());\n  return new BigdataStatementIteratorImpl(kb,src).start(kb.getExecutorService());\n}\n", "nl": "Return iterator visiting the inferences that were added to the KB."}
{"code": "public <V extends Object,C extends RTSpan<V>>void applyEffect(Effect<V,C> effect,V value){\n  if (mUseRTFormatting && !mIsSelectionChanging && !mIsSaving) {\n    Spannable oldSpannable=mIgnoreTextChanges ? null : cloneSpannable();\n    effect.applyToSelection(this,value);\nsynchronized (this) {\n      if (mListener != null && !mIgnoreTextChanges) {\n        Spannable newSpannable=cloneSpannable();\n        mListener.onTextChanged(this,oldSpannable,newSpannable,getSelectionStart(),getSelectionEnd(),getSelectionStart(),getSelectionEnd());\n      }\n      mLayoutChanged=true;\n    }\n  }\n}\n", "nl": "Call this to have an effect applied to the current selection. You get the Effect object via the static data members (e.g., RTEditText.BOLD). The value for most effects is a Boolean, indicating whether to add or remove the effect."}
{"code": "public DefaultLmlParser(final LmlData data,final LmlSyntax syntax,final LmlTemplateReader templateReader,final boolean strict){\n  super(data,syntax,templateReader,new DefaultLmlStyleSheet(),strict);\n}\n", "nl": "Creates a new parser with custom syntax, reader and strict setting."}
{"code": "private static void populateFancy(SQLiteDatabase writableDb){\n  long startOfToday=DateUtil.parse(DateUtil.format(System.currentTimeMillis()));\n  ItemDao.saveItem(writableDb,new Item(Item.TYPE_EXPENSE,\"Clothes\",\"New jeans\",10000,startOfToday,Item.NO_ID));\n  ItemDao.saveItem(writableDb,new Item(Item.TYPE_EXPENSE,\"Flat / House\",\"Monthly rent\",35000,startOfToday,Item.NO_ID));\n  ItemDao.saveItem(writableDb,new Item(Item.TYPE_EXPENSE,\"Grocery\",\"Fruits & vegetables\",3567,DateUtil.parse(\"19/08/2015\"),Item.NO_ID));\n  ItemDao.saveItem(writableDb,new Item(Item.TYPE_EXPENSE,\"Fuel\",\"Full gas tank\",7590,DateUtil.parse(\"14/08/2015\"),Item.NO_ID));\n  ItemDao.saveItem(writableDb,new Item(Item.TYPE_EXPENSE,\"Clothes\",\"New shirt\",3599,DateUtil.parse(\"11/08/2015\"),Item.NO_ID));\n  ItemDao.saveItem(writableDb,new Item(Item.TYPE_EXPENSE,\"Restaurant\",\"Family get together\",3691,DateUtil.parse(\"05/08/2015\"),Item.NO_ID));\n  ItemDao.saveItem(writableDb,new Item(Item.TYPE_INCOME,\"Salary\",\"\",90000,DateUtil.parse(\"31/07/2015\"),Item.NO_ID));\n  ItemDao.saveItem(writableDb,new Item(Item.TYPE_EXPENSE,\"Personal care\",\"New perfume\",3865,DateUtil.parse(\"29/07/2015\"),Item.NO_ID));\n  ItemDao.saveItem(writableDb,new Item(Item.TYPE_EXPENSE,\"Grocery\",\"Bottle of milk\",345,DateUtil.parse(\"26/07/2015\"),Item.NO_ID));\n}\n", "nl": "Generates reasonable amount of good-looking income / expense items."}
{"code": "public TestEntity(int index,String text,String value,double minConfidence){\n  super(index,text);\n  this.value=value;\n  this.minConfidence=minConfidence;\n}\n", "nl": "New instance, with a value."}
{"code": "public boolean contains(JComponent a,int b,int c){\n  boolean returnValue=((ComponentUI)(uis.elementAt(0))).contains(a,b,c);\n  for (int i=1; i < uis.size(); i++) {\n    ((ComponentUI)(uis.elementAt(i))).contains(a,b,c);\n  }\n  return returnValue;\n}\n", "nl": "Invokes the <code>contains</code> method on each UI handled by this object."}
{"code": "public boolean isClosed(){\n  return closed;\n}\n", "nl": "Returns true if this contour path is closed (loops back on itself) or false if it is not."}
{"code": "public void store(float val,Offset offset){\n  this.plus(offset).store(val);\n}\n", "nl": "Stores the float value in the memory location pointed to by the current instance."}
{"code": "public List<IvrZone> showIvrZones(boolean active) throws NetworkDeviceControllerException {\n  List<IvrZone> zones=new ArrayList<IvrZone>();\n  SSHPrompt[] prompts={SSHPrompt.POUND,SSHPrompt.GREATER_THAN};\n  StringBuilder buf=new StringBuilder();\n  String cmdKey=active ? \"MDSDialog.ivr.show.zone.active.cmd\" : \"MDSDialog.ivr.show.zone.cmd\";\n  sendWaitFor(MDSDialogProperties.getString(cmdKey),defaultTimeout,prompts,buf);\n  String[] lines=getLines(buf);\n  IvrZone zone=null;\n  IvrZoneMember member=null;\n  String[] regex={MDSDialogProperties.getString(\"MDSDialog.ivr.showZoneset.zone.name.match\"),MDSDialogProperties.getString(\"MDSDialog.ivr.showZoneset.zone.member.match\")};\n  String[] groups=new String[10];\n  for (  String line : lines) {\n    int index=match(line,regex,groups);\nswitch (index) {\ncase 0:\n      zone=new IvrZone(groups[0]);\n    zones.add(zone);\n  break;\ncase 1:\nmember=new IvrZoneMember(groups[0],Integer.valueOf(groups[3]));\nzone.getMembers().add(member);\nbreak;\n}\n}\nreturn zones;\n}\n", "nl": "Get switch ivr zones"}
{"code": "public static void append(File file,Reader reader,String charset) throws IOException {\n  append(file,reader,charset,false);\n}\n", "nl": "Append the text supplied by the Reader at the end of the File without writing a BOM, using a specified encoding."}
{"code": "public static LifetimeAttribute createLifetimeAttribute(int lifetime){\n  LifetimeAttribute attribute=new LifetimeAttribute();\n  attribute.setLifetime(lifetime);\n  return attribute;\n}\n", "nl": "Create a LifetimeAttribute."}
{"code": "public void testFilePrimary() throws Exception {\n  start();\n  igfsPrimary.create(FILE,true).close();\n  checkEvictionPolicy(0,0);\n  int blockSize=igfsPrimary.info(FILE).blockSize();\n  append(FILE,blockSize);\n  checkEvictionPolicy(0,0);\n  read(FILE,0,blockSize);\n  checkEvictionPolicy(0,0);\n}\n", "nl": "Test how evictions are handled for a file working in PRIMARY mode."}
{"code": "public static String createTestPtStationCSVFile(File file){\n  try (BufferedWriter bw=new BufferedWriter(new FileWriter(file))){\n    bw.write(\"id,x,y\");\n    bw.newLine();\n    bw.write(\"1,10,10\");\n    bw.newLine();\n    bw.write(\"2,10, 190\");\n    bw.newLine();\n    bw.write(\"3,190,190\");\n    bw.newLine();\n    bw.write(\"4,190,10\");\n    bw.newLine();\n    return file.getCanonicalPath();\n  }\n catch (  IOException e) {\n    throw new RuntimeException(e);\n  }\n}\n", "nl": "This method creates 4 pt stops for the test network from createTestNetwork(). The information about the coordinates will be written to a csv file. The 4 pt stops are located as a square in the coordinate plane with a side length of 180 meter (see the sketch below)."}
{"code": "@Override public int hashCode(){\n  int result=super.hashCode();\n  return result;\n}\n", "nl": "Returns a hash code for the renderer."}
{"code": "@Override public void eUnset(int featureID){\nswitch (featureID) {\ncase SGenPackage.FEATURE_TYPE__DEPRECATED:\n    setDeprecated(DEPRECATED_EDEFAULT);\n  return;\ncase SGenPackage.FEATURE_TYPE__COMMENT:\nsetComment(COMMENT_EDEFAULT);\nreturn;\ncase SGenPackage.FEATURE_TYPE__PARAMETERS:\ngetParameters().clear();\nreturn;\ncase SGenPackage.FEATURE_TYPE__OPTIONAL:\nsetOptional(OPTIONAL_EDEFAULT);\nreturn;\n}\nsuper.eUnset(featureID);\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public boolean isVMAX3VolumeCompressionEnabled(URI blockObjectURI){\n  VirtualPool virtualPool=null;\n  Volume volume=null;\n  if (URIUtil.isType(blockObjectURI,Volume.class)) {\n    volume=_dbClient.queryObject(Volume.class,blockObjectURI);\n  }\n else   if (URIUtil.isType(blockObjectURI,BlockSnapshot.class)) {\n    BlockSnapshot snapshot=_dbClient.queryObject(BlockSnapshot.class,blockObjectURI);\n    volume=_dbClient.queryObject(Volume.class,snapshot.getParent());\n  }\n else   if (URIUtil.isType(blockObjectURI,BlockMirror.class)) {\n    BlockMirror mirror=_dbClient.queryObject(BlockMirror.class,blockObjectURI);\n    virtualPool=_dbClient.queryObject(VirtualPool.class,mirror.getVirtualPool());\n  }\n  if (volume != null) {\n    virtualPool=_dbClient.queryObject(VirtualPool.class,volume.getVirtualPool());\n  }\n  return ((virtualPool != null) && virtualPool.getCompressionEnabled());\n}\n", "nl": "This method is will check if the volume associated with virtual Pool has compression enabled."}
{"code": "public void releaseConnection(Database conn){\n  if (conn != null)   conn.close();\n}\n", "nl": "Releases a connection."}
{"code": "public final void testRemoveHelperTextId(){\n  PasswordEditText passwordEditText=new PasswordEditText(getContext());\n  passwordEditText.addHelperTextId(android.R.string.cancel);\n  passwordEditText.addHelperTextId(android.R.string.copy);\n  passwordEditText.removeHelperTextId(android.R.string.cancel);\n  passwordEditText.removeHelperTextId(android.R.string.cancel);\n  assertEquals(1,passwordEditText.getHelperTexts().size());\n  assertEquals(getContext().getText(android.R.string.copy),passwordEditText.getHelperTexts().iterator().next());\n}\n", "nl": "Tests the functionality of the method, which allows to remove a helper text by its id."}
{"code": "private void logMessage(String msg,Object[] obj){\n  if (getMonitoringPropertiesLoader().isToLogIndications()) {\n    _logger.debug(msg,obj);\n  }\n}\n", "nl": "Log the messages. This method eliminates the logging condition check every time when we need to log a message."}
{"code": "public static Float toRef(float f){\n  return new Float(f);\n}\n", "nl": "cast a float value to his (CFML) reference type Float"}
{"code": "@Override protected boolean shouldComposeCreationImage(){\n  return true;\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public synchronized void promote(Tile tile){\n  if (tileQueue.contains(tile)) {\n    try {\n      tileQueue.remove(tile);\n      tile.setPriority(Tile.Priority.High);\n      tileQueue.put(tile);\n    }\n catch (    Exception ex) {\n      ex.printStackTrace();\n    }\n  }\n}\n", "nl": "Increase the priority of this tile so it will be loaded sooner."}
{"code": "public void exitApp(){\n  this.webView.getPluginManager().postMessage(\"exit\",null);\n}\n", "nl": "Exit the Android application."}
{"code": "public void test_getInnerCause01_reject_otherType(){\n  Throwable t=new Throwable();\n  assertNull(getInnerCause(t,Exception.class));\n}\n", "nl": "Does not find cause when it is on top of the stack trace and not either the desired type or a subclass of the desired type."}
{"code": "public Handshake handshake(){\n  return handshake;\n}\n", "nl": "Returns the TLS handshake of the connection that carried this response, or null if the response was received without TLS."}
{"code": "private Coordinate averagePoint(CoordinateSequence seq){\n  Coordinate a=new Coordinate(0,0,0);\n  int n=seq.size();\n  for (int i=0; i < n; i++) {\n    a.x+=seq.getOrdinate(i,CoordinateSequence.X);\n    a.y+=seq.getOrdinate(i,CoordinateSequence.Y);\n    a.z+=seq.getOrdinate(i,CoordinateSequence.Z);\n  }\n  a.x/=n;\n  a.y/=n;\n  a.z/=n;\n  return a;\n}\n", "nl": "Computes a point which is the average of all coordinates in a sequence. If the sequence lies in a single plane, the computed point also lies in the plane."}
{"code": "public static void invokeWebserviceASync(WSDefinition def,SuccessCallback scall,FailureCallback fcall,Object... arguments){\n  WSConnection cr=new WSConnection(def,scall,fcall,arguments);\n  NetworkManager.getInstance().addToQueue(cr);\n}\n", "nl": "Invokes a web asynchronously and calls the callback on completion"}
{"code": "public PutResponseMessage(PutResponseMessage other){\n  if (other.isSetHeader()) {\n    this.header=new AsyncMessageHeader(other.header);\n  }\n}\n", "nl": "Performs a deep copy on <i>other</i>."}
{"code": "private boolean isSynthetic(Method m){\n  if ((m.getAccessFlags() & Constants.ACC_SYNTHETIC) != 0) {\n    return true;\n  }\n  Attribute[] attrs=m.getAttributes();\n  for (  Attribute attr : attrs) {\n    if (attr instanceof Synthetic) {\n      return true;\n    }\n  }\n  return false;\n}\n", "nl": "Methods marked with the \"Synthetic\" attribute do not appear in the source code"}
{"code": "public boolean isTagline(){\n  return tagline;\n}\n", "nl": "Checks if is tagline."}
{"code": "protected LocaTable(TrueTypeFont ttf){\n  super(TrueTypeTable.LOCA_TABLE);\n  MaxpTable maxp=(MaxpTable)ttf.getTable(\"maxp\");\n  int numGlyphs=maxp.getNumGlyphs();\n  HeadTable head=(HeadTable)ttf.getTable(\"head\");\n  short format=head.getIndexToLocFormat();\n  isLong=(format == 1);\n  offsets=new int[numGlyphs + 1];\n}\n", "nl": "Creates a new instance of HmtxTable"}
{"code": "public static <T>T create(Class<T> theQueryClass){\n  return AgentClass.createAgent(theQueryClass);\n}\n", "nl": "Create a database query dynamically"}
{"code": "@DSComment(\"From safe class list\") @DSSafe(DSCat.SAFE_LIST) @DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 13:02:44.163 -0500\",hash_original_method=\"CE28B7D5A93F674A0286463AAF68C789\",hash_generated_method=\"4C5D61097E13A407D793E43190510D41\") public synchronized void addFailure(Test test,AssertionFailedError t){\n  fFailures.addElement(new TestFailure(test,t));\n  for (Enumeration e=cloneListeners().elements(); e.hasMoreElements(); ) {\n    ((TestListener)e.nextElement()).addFailure(test,t);\n  }\n}\n", "nl": "Adds a failure to the list of failures. The passed in exception caused the failure."}
{"code": "public ExtendedKeyUsage(byte[] encoding){\n  super(encoding);\n}\n", "nl": "Creates the extension object on the base of its encoded form."}
{"code": "public Iterator<E> subsetIterator(E from,E to){\n  return new BinarySearchTreeIterator<E>(this.root,from,to);\n}\n", "nl": "Returns the in-order (ascending) iterator."}
{"code": "public int valueForXPosition(int xPos){\n  int value;\n  int minValue=slider.getMinimum();\n  int maxValue=slider.getMaximum();\n  int trackLeft=trackRect.x + thumbRect.width / 2 + trackBorder;\n  int trackRight=trackRect.x + trackRect.width - thumbRect.width / 2 - trackBorder;\n  int trackLength=trackRight - trackLeft;\n  if (xPos <= trackLeft) {\n    value=drawInverted() ? maxValue : minValue;\n  }\n else   if (xPos >= trackRight) {\n    value=drawInverted() ? minValue : maxValue;\n  }\n else {\n    int distanceFromTrackLeft=xPos - trackLeft;\n    double valueRange=(double)maxValue - (double)minValue;\n    double valuePerPixel=valueRange / (double)trackLength;\n    int valueFromTrackLeft=(int)Math.round(distanceFromTrackLeft * valuePerPixel);\n    value=drawInverted() ? maxValue - valueFromTrackLeft : minValue + valueFromTrackLeft;\n  }\n  return value;\n}\n", "nl": "Returns a value give an x position. If xPos is past the track at the left or the right it will set the value to the min or max of the slider, depending if the slider is inverted or not."}
{"code": "@Override protected EClass eStaticClass(){\n  return SRuntimePackage.Literals.COMPOSITE_SLOT;\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public static void main(final String[] args){\n  DOMTestCase.doMain(documentcreateattributeNS03.class,args);\n}\n", "nl": "Runs this test from the command line."}
{"code": "public ListIterator<AbstractInsnNode> iterator(){\n  return iterator(0);\n}\n", "nl": "Returns an iterator over the instructions in this list."}
{"code": "public static String escapeXml(String str){\n  if (str == null) {\n    return null;\n  }\n  return EntitiesUtils.XML.escape(str);\n}\n", "nl": "<p>Escapes the characters in a <code>String</code> using XML entities.</p> <p>For example: <tt>\"bread\" & \"butter\"</tt> => <tt>&amp;quot;bread&amp;quot; &amp;amp; &amp;quot;butter&amp;quot;</tt>. </p> <p>Supports only the five basic XML entities (gt, lt, quot, amp, apos). Does not support DTDs or external entities.</p> <p>Note that unicode characters greater than 0x7f are currently escaped to  their numerical \\\\u equivalent. This may change in future releases. </p>"}
{"code": "public boolean isProcessed(){\n  Object oo=get_Value(COLUMNNAME_Processed);\n  if (oo != null) {\n    if (oo instanceof Boolean)     return ((Boolean)oo).booleanValue();\n    return \"Y\".equals(oo);\n  }\n  return false;\n}\n", "nl": "Get Processed."}
{"code": "public AnnotationAtttributeProposalInfo(IJavaProject project,CompletionProposal proposal){\n  super(project,proposal);\n}\n", "nl": "Creates a new proposal info."}
{"code": "public static void restoreReminderPreference(Context context){\n  int hour=MehPreferencesManager.getNotificationPreferenceHour(context);\n  int minute=MehPreferencesManager.getNotificationPreferenceMinute(context);\n  scheduleDailyReminder(context,hour,minute);\n}\n", "nl": "Restore the daily reminder, with the times already in preferences. Useful for device reboot or switched on from the settings screen"}
{"code": "@Override public boolean isActive(){\n  return amIActive;\n}\n", "nl": "Used by the Whitebox GUI to tell if this plugin is still running."}
{"code": "BarChart(){\n}\n", "nl": "Instantiates a new bar chart."}
{"code": "public boolean isTransactionRelevant(Transaction tx) throws ScriptException {\n  lock.lock();\n  try {\n    return tx.getValueSentFromMe(this).signum() > 0 || tx.getValueSentToMe(this).signum() > 0 || !findDoubleSpendsAgainst(tx,transactions).isEmpty();\n  }\n  finally {\n    lock.unlock();\n  }\n}\n", "nl": "<p>Returns true if the given transaction sends coins to any of our keys, or has inputs spending any of our outputs, and also returns true if tx has inputs that are spending outputs which are not ours but which are spent by pending transactions.</p> <p>Note that if the tx has inputs containing one of our keys, but the connected transaction is not in the wallet, it will not be considered relevant.</p>"}
{"code": "public void free(GL2 gl){\n  if (vbos[0] >= 0) {\n    gl.glDeleteBuffers(1,vbos,0);\n  }\n  vbos[0]=-1;\n}\n", "nl": "Free all memory allocations."}
{"code": "public Vector3(float x,float y,float z){\n  this.set(x,y,z);\n}\n", "nl": "Creates a vector with the given components"}
{"code": "protected S_ActionImpl(){\n  super();\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public void clear(int maximumCapacity){\n  if (capacity <= maximumCapacity) {\n    clear();\n    return;\n  }\n  zeroValue=null;\n  hasZeroValue=false;\n  size=0;\n  resize(maximumCapacity);\n}\n", "nl": "Clears the map and reduces the size of the backing arrays to be the specified capacity if they are larger."}
{"code": "public void bulkLoad(DBIDs ids){\n  if (ids.size() == 0) {\n    return;\n  }\n  assert (root == null) : \"Tree already initialized.\";\n  DBIDIter it=ids.iter();\n  DBID first=DBIDUtil.deref(it);\n  ModifiableDoubleDBIDList candidates=DBIDUtil.newDistanceDBIDList(ids.size() - 1);\n  for (it.advance(); it.valid(); it.advance()) {\n    candidates.add(distance(first,it),it);\n  }\n  root=bulkConstruct(first,Integer.MAX_VALUE,candidates);\n}\n", "nl": "Bulk-load the index."}
{"code": "protected ExtendedSolrQueryParser createEdismaxQueryParser(QParser qParser,String field){\n  return new ExtendedSolrQueryParser(qParser,field);\n}\n", "nl": "Creates an instance of ExtendedSolrQueryParser, the query parser that's going to be used to parse the query."}
{"code": "protected void appendSummary(StringBuffer buffer,String fieldName,long[] array){\n  appendSummarySize(buffer,fieldName,array.length);\n}\n", "nl": "<p>Append to the <code>toString</code> a summary of a <code>long</code> array.</p>"}
{"code": "protected UndoableEdit editToBeRedone(){\n  int count=edits.size();\n  int i=indexOfNextAdd;\n  while (i < count) {\n    UndoableEdit edit=edits.elementAt(i++);\n    if (edit.isSignificant()) {\n      return edit;\n    }\n  }\n  return null;\n}\n", "nl": "Returns the the next significant edit to be redone if <code>redo</code> is invoked. This returns <code>null</code> if there are no edits to be redone."}
{"code": "public void actionPerformed(ActionEvent e){\n  Box b1=Box.createVerticalBox();\n  Version currentVersion=Version.currentViewableVersion();\n  String copyright=LicenseUtils.copyright();\n  copyright=copyright.replaceAll(\"\\n\",\"<br>\");\n  String latestVersion=LatestClient.getInstance().getLatestResult(60);\n  latestVersion=latestVersion.replaceAll(\"\\n\",\"<br>\");\n  JLabel label=new JLabel();\n  label.setText(\"<html>\" + \"<b>Tetrad \" + currentVersion + \"</b>\"+ \"<br>\"+ \"<br>Laboratory for Symbolic and Educational Computing\"+ \"<br>Department of Philosophy\"+ \"<br>Carnegie Mellon University\"+ \"<br>\"+ \"<br>Project Direction: Clark Glymour, Richard Scheines, Peter Spirtes\"+ \"<br>Lead Developer: Joseph Ramsey\"+ \"<br>\"+ copyright+ \"<br>\"+ latestVersion+ \"</html>\");\n  label.setBackground(Color.LIGHT_GRAY);\n  label.setFont(new Font(\"Dialog\",Font.PLAIN,12));\n  label.setBorder(new CompoundBorder(new LineBorder(Color.DARK_GRAY),new EmptyBorder(10,10,10,10)));\n  b1.add(label);\n  JOptionPane.showMessageDialog(JOptionUtils.centeringComp(),b1,\"About Tetrad...\",JOptionPane.PLAIN_MESSAGE);\n}\n", "nl": "Closes the frontmost session of this action's desktop."}
{"code": "private void redrawMarkers(){\n  UI.execute(null);\n}\n", "nl": "Redraw all markers and set them straight to their current locations without animations."}
{"code": "public void addToolTipSeries(List toolTips){\n  this.toolTipSeries.add(toolTips);\n}\n", "nl": "Adds a list of tooltips for a series."}
{"code": "static private String[] alphaMixedNumeric(){\n  return StringFunctions.combineStringArrays(StringFunctions.alphaMixed(),StringFunctions.numeric);\n}\n", "nl": "Combine the alpha mixed and numeric collections into one"}
{"code": "long incrementInMsgs(){\n  return inMsgs.incrementAndGet();\n}\n", "nl": "Increments the number of messages received on this connection."}
{"code": "public final void yyreset(java.io.Reader reader){\n  zzBuffer=s.array;\n  zzStartRead=s.offset;\n  zzEndRead=zzStartRead + s.count - 1;\n  zzCurrentPos=zzMarkedPos=s.offset;\n  zzLexicalState=YYINITIAL;\n  zzReader=reader;\n  zzAtEOF=false;\n}\n", "nl": "Resets the scanner to read from a new input stream. Does not close the old reader. All internal variables are reset, the old input stream <b>cannot</b> be reused (internal buffer is discarded and lost). Lexical state is set to <tt>YY_INITIAL</tt>."}
{"code": "public IntArraySpliterator(int[] array,int origin,int fence,int additionalCharacteristics){\n  this.array=array;\n  this.index=origin;\n  this.fence=fence;\n  this.characteristics=additionalCharacteristics | Spliterator.SIZED | Spliterator.SUBSIZED;\n}\n", "nl": "Creates a spliterator covering the given array and range"}
{"code": "@Override public void populateDAG(DAG dag,Configuration conf){\n  TweetsInput input=new TweetsInput();\n  Collector collector=new Collector();\n  WindowOption windowOption=new WindowOption.GlobalWindow();\n  ApexStream<String> tags=StreamFactory.fromInput(input,input.output,name(\"tweetSampler\")).flatMap(new ExtractHashtags());\n  tags.window(windowOption,new TriggerOption().accumulatingFiredPanes().withEarlyFiringsAtEvery(1)).addCompositeStreams(ComputeTopCompletions.top(10,true)).print(name(\"console\")).endWith(collector,collector.input,name(\"collector\")).populateDag(dag);\n}\n", "nl": "Populate the dag with High-Level API."}
{"code": "public void onScanImageClick(View v){\n  Intent intent=new Intent(this,ScanImageActivity.class);\n  intent.putExtra(ExtrasKeys.EXTRAS_LICENSE_KEY,LICENSE_KEY);\n  intent.putExtra(ExtrasKeys.EXTRAS_RECOGNITION_SETTINGS,mRecognitionSettings);\n  startActivityForResult(intent,MY_REQUEST_CODE);\n}\n", "nl": "Handler for \"Scan Image\" button"}
{"code": "public boolean isReadOnly(){\n  Object oo=get_Value(COLUMNNAME_IsReadOnly);\n  if (oo != null) {\n    if (oo instanceof Boolean)     return ((Boolean)oo).booleanValue();\n    return \"Y\".equals(oo);\n  }\n  return false;\n}\n", "nl": "Get Read Only."}
{"code": "public static <K,V>Map<K,V> asSynchronized(Map<K,V> self){\n  return Collections.synchronizedMap(self);\n}\n", "nl": "A convenience method for creating a synchronized Map."}
{"code": "private boolean isRecursive(Nonterminal nonterm){\n  return comp.getNodes().contains(nonterm);\n}\n", "nl": "Return true if the nonterminal is recursive."}
{"code": "private void initInfo(int record_id,String value){\n  if (!(record_id == 0) && value != null && value.length() > 0) {\n    log.severe(\"Received both a record_id and a value: \" + record_id + \" - \"+ value);\n  }\n  if (!(record_id == 0)) {\n    fieldID=record_id;\n  }\n else {\n    if (value != null && value.length() > 0) {\n      fDocumentNo.setValue(value);\n    }\n else {\n      String id;\n      id=Env.getContext(Env.getCtx(),p_WindowNo,p_TabNo,\"M_InOut_ID\",true);\n      if (id != null && id.length() != 0 && (new Integer(id).intValue() > 0)) {\n        fieldID=new Integer(id).intValue();\n      }\n      id=Env.getContext(Env.getCtx(),p_WindowNo,p_TabNo,\"C_BPartner_ID\",true);\n      if (id != null && id.length() != 0 && (new Integer(id).intValue() > 0))       fBPartner_ID.setValue(new Integer(id));\n      id=Env.getContext(Env.getCtx(),p_WindowNo,p_TabNo,\"M_Shipper_ID\",true);\n      if (id != null && id.length() != 0 && (new Integer(id).intValue() > 0)) {\n        fShipper_ID.setValue(new Integer(id).intValue());\n      }\n    }\n  }\n}\n", "nl": "General Init"}
{"code": "public IssueMatcher add(){\n  IssueMatcher issueMatcher=new IssueMatcher();\n  issueMatchers.add(issueMatcher);\n  return issueMatcher;\n}\n", "nl": "Creates a new issue matcher and adds it to this matcher."}
{"code": "protected ParameterizedPropertyAccessExpression_IMImpl(){\n  super();\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "private void loadFinishScreen(){\n  CoordinatorLayout.LayoutParams lp=new CoordinatorLayout.LayoutParams(CoordinatorLayout.LayoutParams.WRAP_CONTENT,CoordinatorLayout.LayoutParams.WRAP_CONTENT);\n  mFloatingActionButton.setLayoutParams(lp);\n  mFloatingActionButton.setVisibility(View.INVISIBLE);\n  NestedScrollView contentLayout=(NestedScrollView)findViewById(R.id.challenge_rootcontainer);\n  if (contentLayout != null) {\n    contentLayout.removeAllViews();\n    View view=getLayoutInflater().inflate(R.layout.fragment_finish_challenge,contentLayout,false);\n    contentLayout.addView(view);\n  }\n}\n", "nl": "Loads the finish screen and unloads all other screens"}
{"code": "private void compactSegment(Segment segment,OffsetPredicate predicate,Segment compactSegment){\n  for (long i=segment.firstIndex(); i <= segment.lastIndex(); i++) {\n    checkEntry(i,segment,predicate,compactSegment);\n  }\n}\n", "nl": "Compacts the given segment."}
{"code": "public String toString(int indentFactor) throws JSONException {\n  return toString(indentFactor,0);\n}\n", "nl": "Make a prettyprinted JSON text of this JSONObject. <p> Warning: This method assumes that the data structure is acyclical."}
{"code": "@SuppressWarnings(\"MethodWithMultipleReturnPoints\") public static boolean checkSu(){\n  if (!new File(\"/system/bin/su\").exists() && !new File(\"/system/xbin/su\").exists()) {\n    Log.e(TAG,\"su binary does not exist!!!\");\n    return false;\n  }\n  try {\n    if (runSuCommand(\"ls /data/app-private\").success()) {\n      Log.i(TAG,\" SU exists and we have permission\");\n      return true;\n    }\n else {\n      Log.i(TAG,\" SU exists but we don't have permission\");\n      return false;\n    }\n  }\n catch (  NullPointerException e) {\n    Log.e(TAG,\"NullPointer throw while looking for su binary\",e);\n    return false;\n  }\n}\n", "nl": "Checks device for SuperUser permission"}
{"code": "public String toString(int indentFactor) throws JSONException {\n  StringWriter sw=new StringWriter();\nsynchronized (sw.getBuffer()) {\n    return this.write(sw,indentFactor,0).toString();\n  }\n}\n", "nl": "Make a prettyprinted JSON text of this JSONArray. Warning: This method assumes that the data structure is acyclical."}
{"code": "public Boolean isHttpSupportInformation(){\n  return httpSupportInformation;\n}\n", "nl": "Ruft den Wert der httpSupportInformation-Eigenschaft ab."}
{"code": "public static URLConnection createConnectionToURL(final String url,final Map<String,String> requestHeaders) throws IOException {\n  final URL connectionURL=URLUtility.stringToUrl(url);\n  if (connectionURL == null) {\n    throw new IOException(\"Invalid url format: \" + url);\n  }\n  final URLConnection urlConnection=connectionURL.openConnection();\n  urlConnection.setConnectTimeout(CONNECTION_TIMEOUT);\n  urlConnection.setReadTimeout(READ_TIMEOUT);\n  if (requestHeaders != null) {\n    for (    final Map.Entry<String,String> entry : requestHeaders.entrySet()) {\n      urlConnection.setRequestProperty(entry.getKey(),entry.getValue());\n    }\n  }\n  return urlConnection;\n}\n", "nl": "Create URLConnection instance."}
{"code": "public ASN1Primitive toASN1Primitive(){\n  try {\n    if (certificateType == profileType) {\n      return profileToASN1Object();\n    }\n    if (certificateType == requestType) {\n      return requestToASN1Object();\n    }\n  }\n catch (  IOException e) {\n    return null;\n  }\n  return null;\n}\n", "nl": "create a \"request\" or \"profile\" type Iso7816CertificateBody according to the variables sets."}
{"code": "public Builder mapper(final Mapper<ObjectMapper> mapper){\n  this.mapper=mapper;\n  return this;\n}\n", "nl": "Override all of the builder options with this mapper.  If this value is set to something other than null then that value will be used to construct the writer."}
{"code": "private int[][] div(int[] a,int[] f){\n  int df=computeDegree(f);\n  int da=computeDegree(a) + 1;\n  if (df == -1) {\n    throw new ArithmeticException(\"Division by zero.\");\n  }\n  int[][] result=new int[2][];\n  result[0]=new int[1];\n  result[1]=new int[da];\n  int hc=headCoefficient(f);\n  hc=field.inverse(hc);\n  result[0][0]=0;\n  System.arraycopy(a,0,result[1],0,result[1].length);\n  while (df <= computeDegree(result[1])) {\n    int[] q;\n    int[] coeff=new int[1];\n    coeff[0]=field.mult(headCoefficient(result[1]),hc);\n    q=multWithElement(f,coeff[0]);\n    int n=computeDegree(result[1]) - df;\n    q=multWithMonomial(q,n);\n    coeff=multWithMonomial(coeff,n);\n    result[0]=add(coeff,result[0]);\n    result[1]=add(q,result[1]);\n  }\n  return result;\n}\n", "nl": "Compute the result of the division of two polynomials over the field <tt>GF(2^m)</tt>."}
{"code": "public static short toShort(byte[] bytes,int start){\n  return toShort(bytes[start],bytes[start + 1]);\n}\n", "nl": "Returns short from given array of bytes. <br> Array must have at least start + 2 elements in it."}
{"code": "@Override public Double hincrByFloat(final String key,final String field,final double value){\n  checkIsInMultiOrPipeline();\n  client.hincrByFloat(key,field,value);\n  final String dval=client.getBulkReply();\n  return (dval != null ? new Double(dval) : null);\n}\n", "nl": "Increment the number stored at field in the hash at key by a double precision floating point value. If key does not exist, a new key holding a hash is created. If field does not exist or holds a string, the value is set to 0 before applying the operation. Since the value argument is signed you can use this command to perform both increments and decrements. <p> The range of values supported by HINCRBYFLOAT is limited to double precision floating point values. <p> <b>Time complexity:</b> O(1)"}
{"code": "public DrawerBuilder withFooter(@NonNull View footerView){\n  this.mFooterView=footerView;\n  return this;\n}\n", "nl": "Add a footer to the DrawerBuilder ListView. This can be any view"}
{"code": "@Override public int compareTo(final Object obj) throws ClassCastException {\n  final URI another=(URI)obj;\n  if (!equals(_authority,another.getRawAuthority())) {\n    return -1;\n  }\n  return toString().compareTo(another.toString());\n}\n", "nl": "Compare this URI to another object."}
{"code": "public boolean isNavigationAtBottom(){\n  return (mSmallestWidthDp >= 600 || mInPortrait);\n}\n", "nl": "Should a navigation bar appear at the bottom of the screen in the current device configuration? A navigation bar may appear on the right side of the screen in certain configurations."}
{"code": "@Override public void execute(String filePath){\n  final CurrentProject currentProject=appContext.getCurrentProject();\n  if (filePath != null && !filePath.startsWith(\"/\")) {\n    filePath=\"/\".concat(filePath);\n  }\n  if (currentProject != null) {\n    String fullPath=currentProject.getRootProject().getPath() + filePath;\n    log.debug(\"Open file {0}\",fullPath);\n    currentProject.getCurrentTree().getNodeByPath(fullPath,new TreeNodeAsyncCallback());\n  }\n}\n", "nl": "Open a file for the current given path."}
{"code": "public void executionDetailsEnd(final ConcurrentHashMap<Integer,TradeOrder> tradeOrders){\n  try {\n    Tradingday todayTradingday=m_tradingdays.getTradingday(TradingCalendar.getTradingDayStart(TradingCalendar.getDateTimeNowMarketTimeZone()),TradingCalendar.getTradingDayEnd(TradingCalendar.getDateTimeNowMarketTimeZone()));\n    if (null == todayTradingday) {\n      return;\n    }\n    tradingdayPanel.doRefresh(todayTradingday);\n    tradingdayPanel.doRefreshTradingdayTable(todayTradingday);\n  }\n catch (  Exception ex) {\n    this.setErrorMessage(\"Error starting PositionManagerRule.\",ex.getMessage(),ex);\n  }\n}\n", "nl": "This method is fired when the Brokermodel has completed the request for Execution Details see doFetchExecution or connectionOpened i.e from a BrokerModel event all executions for the filter have now been received. Check to see if we need to close any trades for these order fills."}
{"code": "public void successfullyCreated(){\n  if (notification != null) {\n    notification.setStatus(SUCCESS);\n    notification.setTitle(locale.createSnapshotSuccess());\n  }\n}\n", "nl": "Changes notification state to successfully finished."}
{"code": "public HybridTimestampFactory(int counterBits){\n  if (counterBits < 0 || counterBits > 31) {\n    throw new IllegalArgumentException(\"counterBits must be in [0:31]\");\n  }\n  lastTimestamp=0L;\n  this.counterBits=counterBits;\n  maxCounter=BigInteger.valueOf(2).pow(counterBits).intValue() - 1;\n  log.warn(\"#counterBits=\" + counterBits + \", maxCounter=\"+ maxCounter);\n}\n", "nl": "Allows up to <code>2^counterBits</code> distinct timestamps per millisecond."}